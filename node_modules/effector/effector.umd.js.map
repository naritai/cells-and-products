{"version":3,"file":"effector.umd.js","sources":["../../src/stdlib/typedef.js","../../src/stdlib/stateref.js","../../src/stdlib/fx.js","../../src/watcher/watcher.js","../../src/graphite/walk.js","../../src/compositeName.js","../../src/event/eventFabric.js","../../src/event/createEvent.js","../../src/store/staticMethods.js","../../src/store/setStoreName.js","../../src/store/storeMethods.js","../../src/store/storeFabric.js","../../src/store/createStore.js","../../src/store/createStoreObject.js","../../src/store/restore.js","../../src/effect/effectFabric.js","../../src/invariant/invariant.js","../../node_modules/symbol-observable/es/index.js","../../node_modules/symbol-observable/es/ponyfill.js","../../src/stdlib/kind.js","../../src/stdlib/refcount.js","../../src/perf/perf.js","../../src/warning/warning.js","../../src/effect/exec.js","../../src/effect/callbacks.js","../../src/domain/hook.js","../../src/domain/domainFabric.js","../../src/effector/combine.js","../../src/domain/createDomain.js","../../src/effect/createEffect.js","../../src/store/createApi.js"],"sourcesContent":["//@flow\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\nexport type ID = string\nexport type TypeDef<+Type, +Group> = {\n  +id: ID,\n  +type: Type,\n  +group: Group,\n  +data: any,\n}\n\nexport type GraphiteMeta = {\n  +next: TypeDef<'multi', 'step'>,\n  +seq: TypeDef<'seq', 'step'>,\n}\n\nexport const Step = typeDef(('step': 'step'), {\n  single: null,\n  multi: null,\n  seq: null,\n  choose: null,\n  loop: null,\n})\n\nexport const Cmd = typeDef(('cmd': 'cmd'), {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null,\n})\n\nexport const Ctx = typeDef(('ctx': 'ctx'), {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null,\n})\n\n//eslint-disable-next-line no-unused-vars\ndeclare function typeDef<T: {+[key: string]: any}, Group>(\n  group: Group,\n  t: T,\n): $ObjMapi<T, <K>(k: K) => (data: any) => TypeDef<K, Group>>\nfunction typeDef(group, t) {\n  const result = {}\n  for (const key in t) {\n    result[key] = type.bind({\n      key,\n      group,\n    })\n  }\n  return result\n}\nfunction type(data) {\n  return {\n    id: nextID(),\n    type: this.key,\n    group: this.group,\n    data,\n  }\n}\n","//@flow\nimport type {ID} from './typedef'\nlet id = 0\n\nexport type StateRef = {\n  +id: ID,\n  current: any,\n}\n\nexport function createStateRef(current: any): StateRef {\n  return {\n    id: (++id).toString(36),\n    current,\n  }\n}\n","//@flow\n/* eslint-disable no-unused-vars */\n\nimport type {StateRef} from './stateref'\nimport {Step, Cmd, type TypeDef} from './typedef'\n\ntype Fun = TypeDef<*, 'step' | 'cmd'>\ntype Using = {\n  name: string,\n  reset?: any,\n}\n\n/* Step */\ndeclare export default function fx(\n  tag: 'loop',\n  props: {\n    branch: Fun,\n    iterator: Fun,\n    source: StateRef,\n    until: Using,\n    selector: Using,\n    item: Using,\n  },\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'loop', 'step'>\ndeclare export default function fx(\n  tag: 'choose',\n  props: {\n    state: StateRef,\n    selector: TypeDef<*, 'step'>,\n    cases: {+[key: string]: TypeDef<*, 'step'>},\n  },\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'choose', 'step'>\ndeclare export default function fx(\n  tag: 'single',\n  props: null,\n  childrens: *,\n): TypeDef<'single', 'step'>\ndeclare export default function fx(\n  tag: 'multi',\n  props: null,\n  ...childrens: *\n): TypeDef<'multi', 'step'>\ndeclare export default function fx(\n  tag: 'seq',\n  props: null,\n  ...childrens: *\n): TypeDef<'seq', 'step'>\n\n/* Cmd */\ndeclare export default function fx(\n  tag: 'compute',\n  props: {fn: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'compute', 'cmd'>\ndeclare export default function fx(\n  tag: 'emit',\n  props: {fullName: string},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'emit', 'cmd'>\ndeclare export default function fx(\n  tag: 'filter',\n  props: {filter: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'filter', 'cmd'>\ndeclare export default function fx(\n  tag: 'run',\n  props: {runner: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'run', 'cmd'>\ndeclare export default function fx(\n  tag: 'update',\n  props: {|store: StateRef|} | {|val: string|},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'update', 'cmd'>\nexport default function fx(\n  tag:\n    | 'choose'\n    | 'single'\n    | 'multi'\n    | 'seq'\n    | 'compute'\n    | 'emit'\n    | 'filter'\n    | 'run'\n    | 'update',\n  props: *,\n  ...childrens: *\n) {\n  if (tag in Cmd) {\n    const tag_: 'compute' | 'emit' | 'filter' | 'run' | 'update' = (tag: any)\n    return Step.single(Cmd[tag_](props))\n  }\n  const tag_: 'single' | 'multi' | 'seq' | 'choose' | 'loop' = (tag: any)\n  switch (tag_) {\n    case 'single':\n      return Step.single(childrens[0])\n    case 'multi':\n      return Step.multi(childrens)\n    case 'seq':\n      return Step.seq(childrens)\n    case 'choose':\n      return Step.choose(props)\n    case 'loop':\n      return Step.loop(props)\n  }\n  if (typeof tag === 'function') return tag(props, childrens)\n  console.error('unknown node \"%s\"', tag)\n  return null\n}\n","//@flow\n\nimport type {TypeDef, GraphiteMeta} from 'effector/stdlib'\nimport type {Watcher} from './index.h'\n\nconst noopIndexOf = () => -1\n//eslint-disable-next-line no-unused-vars\nconst noopSplice = (i: number, n: number) => []\n\nfunction disposer() {\n  const i = this.indexOf()\n  if (i === -1) return\n  this.splice(i, 1)\n  this.indexOf = noopIndexOf\n  this.splice = noopSplice\n}\n\nexport const createWatcher = (opts: {\n  child: TypeDef<*, 'cmd' | 'step'>,\n  parent: GraphiteMeta,\n}): Watcher => {\n  const subscribers = opts.parent.next.data\n  const instance = {\n    indexOf: subscribers.indexOf.bind(subscribers, opts.child),\n    splice: subscribers.splice.bind(subscribers),\n  }\n  const result = disposer.bind(instance)\n  result.unsubscribe = disposer.bind(instance)\n  return (result: $todo)\n}\n","//@flow\n\nimport type {Event} from 'effector/event'\nimport {type TypeDef, Ctx, type StateRef, createStateRef} from 'effector/stdlib'\nimport {__DEV__, __DEBUG__} from 'effector/flags'\nimport type {CommonCtx, Meta, Reg, Command} from './index.h'\n\nexport function walkEvent<T>(payload: T, event: Event<T>) {\n  walkNode(\n    event.graphite.seq,\n    Ctx.emit({\n      __stepArg: payload,\n    }),\n  )\n}\n\nexport function walkNode(seq: TypeDef<'seq', 'step'>, ctx: TypeDef<*, 'ctx'>) {\n  const meta = {\n    transactions: [],\n    stop: false,\n    ctx,\n    reg: {\n      isChanged: true,\n    },\n    val: {},\n  }\n  runStep(seq, meta.ctx, meta)\n  for (let i = 0; i < meta.transactions.length; i++) {\n    meta.transactions[i]()\n  }\n  meta.transactions.length = 0\n}\n\nfunction runStep(step, ctx: *, meta) {\n  meta.stop = false\n  stepVisitor[step.type](step, ctx, meta)\n}\n\nconst commonStepVisitor = {\n  single(step: TypeDef<'single', 'step'>, ctx: CommonCtx, meta: Meta) {\n    meta.arg = ctx.data.__stepArg\n    meta.ctx = command[step.data.type].cmd(step.data, meta)\n    meta.stop = !command[meta.ctx.type].transition(meta.reg)\n  },\n  multi(step, ctx, meta) {\n    const items = step.data.slice()\n    for (let i = 0; i < items.length; i++) {\n      runStep(items[i], ctx, meta)\n    }\n    meta.stop = false\n  },\n  seq(steps: TypeDef<'seq', 'step'>, prev: CommonCtx, meta) {\n    meta.ctx = prev\n    const items = steps.data.slice()\n    for (let i = 0; i < items.length; i++) {\n      runStep(items[i], meta.ctx, meta)\n      if (meta.stop) {\n        break\n      }\n    }\n  },\n}\nconst stepVisitor = {}\nstepVisitor.single = commonStepVisitor.single\nstepVisitor.multi = commonStepVisitor.multi\nstepVisitor.seq = commonStepVisitor.seq\n\nif (__DEBUG__) {\n  const LOOP_TIMEOUT = 5e3\n  const infiniteLoopProtection = start => {\n    if (Date.now() - start > LOOP_TIMEOUT) {\n      throw new Error('infinite loop protection')\n    }\n  }\n  const stepVisitorNext = {\n    loop(step: TypeDef<'loop', 'step'>, ctx: TypeDef<*, 'ctx'>, meta) {\n      const VAL = 'current'\n      type Fun = TypeDef<*, 'step'>\n      type Using = {\n        name: string,\n        reset?: any,\n      }\n      type StepData = {\n        branch: Fun,\n        iterator: Fun,\n        source: StateRef,\n        until: Using,\n        selector: Using,\n        item: Using,\n      }\n      const data: StepData = step.data\n      const branch: Fun = data.branch\n      const iterator: Fun = data.iterator\n\n      const source: StateRef = data.source\n      const until = using(data.until, meta)\n      const selector = using(data.selector, meta)\n      const item = using(data.item, meta)\n\n      const now = Date.now()\n\n      while (until[VAL]) {\n        if (__DEV__) {\n          infiniteLoopProtection(now)\n        }\n        item[VAL] = source[VAL][selector[VAL]]\n        runStep(branch, ctx, meta)\n        runStep(iterator, ctx, meta)\n      }\n\n      function using(opts, meta): StateRef {\n        const name = String(opts.name)\n        if ('reset' in opts) {\n          if (!(name in meta.val)) {\n            meta.val[name] = createStateRef(opts.reset)\n          }\n          meta.val[name][VAL] = opts.reset\n        }\n        return meta.val[name]\n      }\n    },\n    choose(step: TypeDef<'choose', 'step'>, ctx: TypeDef<*, 'ctx'>, meta) {\n      type Cases = {+[key: string]: TypeDef<*, 'step'>}\n      const cases: Cases = step.data.cases\n      runStep(step.data.selector, ctx, meta)\n      const caseName = String(step.data.state.current)\n      let next\n      if (caseName in cases) {\n        next = cases[caseName]\n      } else if ('__' in cases) {\n        next = cases.__\n      } else {\n        console.error('no case \"%s\" exists', caseName)\n        return\n      }\n      runStep(next, ctx, meta)\n    },\n  }\n  stepVisitor.loop = stepVisitorNext.loop\n  stepVisitor.choose = stepVisitorNext.choose\n}\n\nconst command = ({\n  emit: {\n    cmd: (single, meta) =>\n      Ctx.emit({\n        __stepArg: meta.arg,\n      }),\n    transition: () => true,\n  },\n  filter: {\n    cmd(single, meta) {\n      const ctx = Ctx.filter({\n        __stepArg: meta.arg,\n      })\n      const runCtx = tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.filter,\n      })\n      meta.reg.isChanged = Boolean(runCtx.result)\n      return ctx\n    },\n    transition: reg => Boolean(reg.isChanged),\n  },\n  run: {\n    cmd(single, meta) {\n      const ctx = Ctx.run({})\n\n      if ('transactionContext' in single.data)\n        meta.transactions.push(single.data.transactionContext(meta.arg))\n      tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.runner,\n      })\n      return ctx\n    },\n    transition: () => false,\n  },\n  update: {\n    cmd(single, meta) {\n      let store\n      if ('val' in single.data) {\n        store = meta.val[single.data.val] =\n          meta.val[single.data.val] || createStateRef(null)\n      } else {\n        store = single.data.store\n      }\n      store.current = meta.arg\n      return Ctx.update({\n        __stepArg: meta.arg,\n      })\n    },\n    transition: () => true,\n  },\n  compute: {\n    cmd(single, meta) {\n      const newCtx = Ctx.compute({\n        __stepArg: null,\n      })\n      const runCtx = tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.fn,\n      })\n      meta.reg.isChanged = !runCtx.err && runCtx.result !== undefined\n      if (!runCtx.err) {\n        newCtx.data.__stepArg = runCtx.result\n      }\n      return newCtx\n    },\n    transition: reg => Boolean(reg.isChanged),\n  },\n}: {\n  emit: Command<'emit'>,\n  filter: Command<'filter'>,\n  run: Command<'run'>,\n  update: Command<'update'>,\n  compute: Command<'compute'>,\n})\n\nfunction tryRun(ctx) {\n  try {\n    ctx.result = ctx.fn.call(null, ctx.arg, ctx.val)\n  } catch (err) {\n    console.error(err)\n    ctx.err = true\n  }\n  return ctx\n}\n","//@flow\n\nexport type CompositeName = {\n  +shortName: string,\n  +fullName: string,\n  +path: Array<string>,\n}\n\nfunction Name(shortName: string, fullName: string, path: Array<string>) {\n  this.shortName = shortName\n  this.fullName = fullName\n  this.path = path\n}\n\nexport function createName(name: string, parent?: CompositeName) {\n  let path\n  let fullName\n  const shortName = name\n  if (parent === undefined) {\n    if (name.length === 0) {\n      path = ([]: string[])\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    if (name.length === 0) {\n      path = parent.path\n      fullName = parent.fullName\n    } else {\n      path = parent.path.concat([name])\n      if (parent.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + parent.fullName + '/' + name\n      }\n    }\n  }\n  return new Name(shortName, fullName, path)\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n\nimport {\n  //eslint-disable-next-line no-unused-vars\n  fx,\n  Kind,\n  stringRefcount,\n  type GraphiteMeta,\n  type TypeDef,\n} from 'effector/stdlib'\nimport {createWatcher} from 'effector/watcher'\nimport type {Effect} from 'effector/effect'\nimport {walkEvent} from 'effector/graphite'\n\nimport type {Subscription} from '../effector/index.h'\nimport type {Event} from './index.h'\nimport {type CompositeName, createName} from '../compositeName'\n\nconst nextID = stringRefcount()\n\nexport function eventFabric<Payload>({\n  name: nameRaw,\n  parent,\n}: {\n  name?: string,\n  parent?: CompositeName,\n}): Event<Payload> {\n  const id = nextID()\n  const name = nameRaw || id\n  const fullName = makeName(name, parent)\n  const compositeName = createName(name, parent)\n  const graphite = fabric({\n    fullName,\n  })\n\n  //$off\n  const instance: Event<Payload> = (\n    payload: Payload,\n    ...args: any[]\n  ): Payload => instance.create(payload, fullName, args)\n  ;(instance: any).getType = () => compositeName.fullName\n  //eslint-disable-next-line no-unused-vars\n  ;(instance: any).create = (payload, fullName, args) => {\n    walkEvent(payload, instance)\n    return payload\n  }\n  ;(instance: any).kind = Kind.event\n  ;(instance: any)[$$observable] = () => instance\n  ;(instance: any).id = id\n  ;(instance: any).watch = watchEvent.bind(null, instance)\n  ;(instance: any).map = mapEvent.bind(null, instance)\n  ;(instance: any).filter = filterEvent.bind(null, instance)\n  ;(instance: any).prepend = prepend.bind(null, instance)\n  ;(instance: any).subscribe = subscribe.bind(null, instance)\n  instance.graphite = graphite\n  instance.shortName = name\n  instance.domainName = parent\n  instance.compositeName = compositeName\n\n  return instance\n}\n\nfunction subscribe(event, observer): Subscription {\n  return event.watch(payload => observer.next(payload))\n}\n\nfunction prepend(event, fn: (_: any) => *) {\n  const contramapped: Event<any> = eventFabric({\n    name: '* → ' + event.shortName,\n    parent: event.domainName,\n  })\n  forward({\n    from: contramapped,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            {event.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return contramapped\n}\n\ndeclare function mapEvent<A, B>(event: Event<A>, fn: (_: A) => B): Event<B>\ndeclare function mapEvent<A, B>(\n  effect: Effect<A, any, any>,\n  fn: (_: A) => B,\n): Event<B>\nfunction mapEvent<A, B>(event: Event<A> | Effect<A, any, any>, fn: A => B) {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' → *',\n    parent: event.domainName,\n  })\n  forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            {mapped.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return mapped\n}\n\nfunction filterEvent<A, B>(\n  event: Event<A> | Effect<A, any, any>,\n  fn: A => B | void,\n): Event<B> {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' →? *',\n    parent: event.domainName,\n  })\n  forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            <filter filter={result => result !== undefined} />\n            {mapped.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return mapped\n}\n\nfunction watchEvent<Payload>(\n  event: Event<Payload>,\n  watcher: (payload: Payload, type: string) => any,\n): Subscription {\n  return forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: ((\n          <run\n            runner={(newValue: Payload) => watcher(newValue, event.getType())}\n          />\n        ): $todo),\n      },\n    },\n  })\n}\nfunction makeName(name: string, compositeName?: CompositeName) {\n  const fullName = compositeName?.fullName\n  if (!fullName) {\n    if (!name) return ''\n    return name\n  }\n  return '' + fullName + '/' + name\n}\ntype Graphiter = {\n  +graphite: GraphiteMeta,\n  /*::...*/\n}\ntype GraphiterSmall = {\n  +graphite: {\n    +seq: TypeDef<'seq' | 'loop', 'step'>,\n    /*::...*/\n  },\n  /*::...*/\n}\n\nexport function forward(opts: {\n  from: Graphiter,\n  to: GraphiterSmall,\n}): Subscription {\n  const toSeq = opts.to.graphite.seq\n  const fromGraphite = opts.from.graphite\n  fromGraphite.next.data.push(toSeq)\n  return createWatcher({\n    child: toSeq,\n    parent: fromGraphite,\n  })\n}\n\nconst fabric = (args: {fullName: string}): GraphiteMeta => {\n  const nextSteps = <multi />\n  return {\n    next: nextSteps,\n    seq: (\n      <seq>\n        <emit fullName={args.fullName} />\n        {nextSteps}\n      </seq>\n    ),\n  }\n}\n","//@flow\n\nimport {eventFabric} from './eventFabric'\nimport type {Event} from './index.h'\n\nexport function createEvent<Payload>(name?: string): Event<Payload> {\n  return eventFabric({\n    name,\n  })\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport type {CompositeName} from '../compositeName'\n\nexport function withProps<R, S, P>(\n  store: Store<S>,\n  handler: (store: S, props: P) => R,\n): (props: P) => R {\n  return (props: P) => handler(store.getState(), props)\n}\nexport function getDisplayName(store: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (store.compositeName) {\n    return store.compositeName.fullName\n  }\n  if (store.domainName) {\n    return store.domainName.fullName\n  }\n  return store.id\n}\n","//@flow\n\nimport {Kind} from 'effector/stdlib'\nimport {__DEBUG__} from 'effector/flags'\nimport type {Store} from './index.h'\nimport {getDisplayName} from './staticMethods'\nimport {createName} from '../compositeName'\n\nconst storeObjectMaxNames = 25\n\nexport function storeObjectArrayName(arr: $ReadOnlyArray<Store<any> | any>) {\n  let i = 0\n  const max = storeObjectMaxNames - 1\n  const maxLength = arr.length - 1\n  let name = 'combine('\n  for (const store of arr) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    if (store.kind !== Kind.store) {\n      name += store.toString() + comma\n    } else {\n      name += getDisplayName(store) + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n\nexport function storeObjectName(obj: {[key: string]: Store<any> | any}) {\n  let i = 0\n  const keys = Object.keys(obj)\n  const max = storeObjectMaxNames - 1\n  const maxLength = keys.length - 1\n  let name = 'combine('\n  for (const key in obj) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    const store = obj[key]\n    if (store.kind !== Kind.store) {\n      name += store.toString() + comma\n    } else {\n      name += getDisplayName(store) + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, store.domainName)\n  store.shortName = rawName\n  store.compositeName = compositeName\n}\n\nfunction isStoreObject(store: Store<any>) {\n  return (\n    typeof store.kind !== 'undefined'\n    && store.kind === Kind.store\n    //$todo\n    && typeof store.defaultShape !== 'undefined'\n  )\n}\n\nexport function storeNaming<Obj: {[key: string]: Store<any> | Object}>(\n  object: Obj,\n  parent?: Store<any>,\n) {\n  const entries: Array<[string, Store<any>]> = (Object.entries(object): any)\n  for (const [storeName, store] of entries) {\n    if (parent && store.kind === Kind.store) {\n      store.domainName = parent.compositeName || store.domainName\n    }\n\n    if (isStoreObject(store)) {\n      setStoreName(store, storeName)\n      //$todo\n      storeNaming(store.defaultShape, store)\n      continue\n    }\n\n    if (store.kind === Kind.store) {\n      setStoreName(store, storeName)\n      continue\n    }\n\n    if (__DEBUG__)\n      console.warn(\n        'effector: Key \"%s\" must be store but instead received %s',\n        storeName,\n        store.kind || '\"' + typeof store + '\"',\n        store,\n      )\n  }\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind} from 'effector/stdlib'\n\nimport invariant from 'invariant'\nimport {startPhaseTimer, stopPhaseTimer} from 'effector/perf'\n\nimport {forward, type Event} from 'effector/event'\nimport type {Store, ThisStore} from './index.h'\nimport type {Subscriber} from '../effector/index.h'\nimport type {CompositeName} from '../compositeName'\n\nexport function reset(storeInstance: ThisStore, event: Event<any>) {\n  return on.call(this, storeInstance, event, () => storeInstance.defaultState)\n}\nexport function getState(storeInstance: ThisStore) {\n  return storeInstance.plainState.current\n}\nexport function off(storeInstance: ThisStore, event: Event<any>) {\n  const currentSubscription = storeInstance.subscribers.get(event)\n  if (currentSubscription === undefined) return\n  currentSubscription()\n  storeInstance.subscribers.delete(event)\n}\nconst readName = (e: *): string => {\n  switch (e.kind) {\n    case Kind.store:\n      return e.shortName\n    default:\n      return e.getType()\n  }\n}\nexport function on(storeInstance: ThisStore, event: any, handler: Function) {\n  const e: Event<any> = event\n  storeInstance.subscribers.set(\n    e,\n    forward({\n      from: e,\n      to: {\n        graphite: {\n          seq: (\n            <seq>\n              <compute\n                fn={newValue => {\n                  const lastState = getState(storeInstance)\n                  return handler(lastState, newValue, readName(e))\n                }}\n              />\n              <filter\n                filter={data => {\n                  const lastState = getState(storeInstance)\n                  return data !== lastState && data !== undefined\n                }}\n              />\n              {storeInstance.graphite.seq}\n            </seq>\n          ),\n        },\n      },\n    }),\n  )\n  return this\n}\nexport function observable(storeInstance: ThisStore) {\n  const result = {\n    subscribe(observer: Subscriber<any>) {\n      invariant(\n        typeof observer === 'object' && observer !== null,\n        'Expected the observer to be an object.',\n      )\n\n      function observeState(state) {\n        if (observer.next) {\n          observer.next(state)\n        }\n      }\n      return subscribe(storeInstance, observeState)\n    },\n  }\n  //$off\n  result[$$observable] = function() {\n    return this\n  }\n  return result\n}\nexport function watch(\n  storeInstance: ThisStore,\n  eventOrFn: Event<*> | Function,\n  fn?: Function,\n) {\n  const kind = String(eventOrFn?.kind || '__')\n  switch (kind) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      invariant(typeof fn === 'function', 'watch requires function handler')\n      return eventOrFn.watch(payload =>\n        //$todo\n        fn(getState(storeInstance), payload, readName(eventOrFn)),\n      )\n    case '__':\n    default:\n      invariant(\n        typeof eventOrFn === 'function',\n        'watch requires function handler',\n      )\n      return subscribe(storeInstance, eventOrFn)\n  }\n}\nexport function subscribe(storeInstance: ThisStore, listener: Function) {\n  invariant(\n    typeof listener === 'function',\n    'Expected the listener to be a function',\n  )\n  let stopPhaseTimerMessage = null\n  let lastCall = getState(storeInstance)\n\n  startPhaseTimer(storeInstance, 'subscribe')\n  try {\n    listener(lastCall)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n    stopPhaseTimerMessage = 'Got initial error'\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n\n  return forward({\n    from: storeInstance,\n    to: {\n      graphite: {\n        seq: (\n          //$todo\n          <run\n            runner={args => {\n              let stopPhaseTimerMessage = null\n              startPhaseTimer(storeInstance, 'subscribe')\n              if (args === lastCall) {\n                stopPhaseTimer(stopPhaseTimerMessage)\n                return\n              }\n              lastCall = args\n              try {\n                listener(args)\n              } catch (err) {\n                console.error(err)\n                stopPhaseTimerMessage = 'Got error'\n              }\n              stopPhaseTimer(stopPhaseTimerMessage)\n            }}\n          />\n        ),\n      },\n    },\n  })\n}\nexport function thru(fn: Function) {\n  return fn(this)\n}\nexport function dispatch(action: any) {\n  return action\n}\n\nexport function getDisplayName(store: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (store.compositeName) {\n    return store.compositeName.fullName\n  }\n  if (store.domainName) {\n    return store.domainName.fullName\n  }\n  return store.id\n}\n\nexport function mapStore<A, B>(\n  store: Store<A>,\n  fn: (state: A, lastState?: B) => B,\n  firstState?: B,\n): Store<B> {\n  startPhaseTimer(store, 'map')\n  let lastValue = store.getState()\n  let lastResult\n  let stopPhaseTimerMessage = null\n  try {\n    lastResult = fn(lastValue, firstState)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n    stopPhaseTimerMessage = 'Got initial error'\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  const innerStore: Store<any> = this({\n    name: '' + store.shortName + ' → *',\n    currentState: lastResult,\n    parent: store.domainName,\n  })\n  forward({\n    from: store,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute\n              fn={newValue => {\n                startPhaseTimer(store, 'map')\n                lastValue = newValue\n                let stopPhaseTimerMessage = null\n                const lastState = innerStore.getState()\n                let result\n                try {\n                  result = fn(newValue, lastState)\n                } catch (err) {\n                  console.error(err)\n                  stopPhaseTimerMessage = 'Got error'\n                }\n                stopPhaseTimer(stopPhaseTimerMessage)\n                return result\n              }}\n            />\n            <filter\n              filter={result => {\n                const lastState = innerStore.getState()\n                const isChanged = result !== lastState && result !== undefined\n                if (isChanged) {\n                  lastResult = result\n                }\n                stopPhaseTimer(null)\n                return isChanged\n              }}\n            />\n            {innerStore.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return innerStore\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind, createStateRef} from 'effector/stdlib'\nimport {createEvent} from 'effector/event'\n\nimport type {Store, ThisStore} from './index.h'\nimport {setStoreName} from './setStoreName'\nimport type {CompositeName} from '../compositeName'\nimport {\n  reset,\n  getState,\n  off,\n  on,\n  observable,\n  watch,\n  subscribe,\n  thru,\n  dispatch,\n  mapStore,\n} from './storeMethods'\n\nexport function storeFabric<State>(props: {\n  currentState: State,\n  name?: string,\n  parent?: CompositeName,\n}): Store<State> {\n  const {currentState, name, parent} = props\n  const plainState = createStateRef(currentState)\n  const currentId = plainState.id\n  const defaultState = currentState\n\n  const updater: any = createEvent('update ' + currentId)\n  const storeInstance: ThisStore = {\n    graphite: createDef(plainState),\n    kind: Kind.store,\n    id: currentId,\n    shortName: currentId,\n    domainName: parent,\n    defaultState,\n    plainState,\n    subscribers: new Map(),\n  }\n  //TODO fix type\n  //$off\n  if (name) setStoreName(storeInstance, name)\n  const store: $Shape<Store<State>> = {\n    graphite: storeInstance.graphite,\n    kind: Kind.store,\n    id: currentId,\n    shortName: currentId,\n    domainName: parent,\n    setState,\n    off: off.bind(null, storeInstance),\n    watch: watch.bind(null, storeInstance),\n    subscribe: subscribe.bind(null, storeInstance),\n    getState: getState.bind(null, storeInstance),\n  }\n  ;(store: any).reset = reset.bind(store, storeInstance)\n  ;(store: any).on = on.bind(store, storeInstance)\n  ;(store: any).defaultState = defaultState\n  ;(store: any).map = mapStore.bind(storeFabric, store)\n  ;(store: any).thru = thru.bind(store)\n  ;(store: any).dispatch = dispatch.bind(null)\n  //$off\n  store[$$observable] = observable.bind(null, storeInstance)\n  //TODO fix type\n  //$off\n  if (name) setStoreName(store, name)\n  store.on(updater, (_, payload) => payload)\n\n  function setState(value, reduce?: Function) {\n    const currentReducer =\n      typeof reduce === 'function' ? reduce : (_, payload) => payload\n    const state = getState(storeInstance)\n    const newResult = currentReducer(state, value)\n\n    updater(newResult)\n  }\n\n  return store\n}\n\nfunction filterBeforeUpdate(newValue) {\n  return newValue !== undefined && newValue !== this.current\n}\nconst createDef = plainState => {\n  const def = {}\n  def.next = <multi />\n  def.seq = (\n    <seq>\n      <filter filter={filterBeforeUpdate.bind(plainState)} />\n      <update store={plainState} />\n      {def.next}\n    </seq>\n  )\n  return def\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\nexport function createStore<State>(state: State): Store<State> {\n  return storeFabric({\n    currentState: state,\n  })\n}\n","//@flow\n//@jsx fx\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind} from 'effector/stdlib'\n\nimport {createEvent, forward} from 'effector/event'\nimport type {Store} from './index.h'\nimport {storeObjectName, storeObjectArrayName} from './setStoreName'\nimport {storeFabric} from './storeFabric'\n\nfunction createStoreArray<State: $ReadOnlyArray<Store<any> | any>>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n> {\n  const state = [...obj]\n  const stateNew = [...obj]\n\n  const updater: any = createEvent('update ' + Math.random().toString())\n\n  let updates: Array<(state: any) => any> = []\n  const committer = () => {\n    updates = []\n    return () => {\n      let current = store.getState()\n      for (const fn of updates) {\n        current = fn(current)\n      }\n      commit = committer()\n      updater(current)\n    }\n  }\n  let commit = committer()\n  for (const [key, child] of state.map((e, i) => [i, e])) {\n    if (child.kind === Kind.store) {\n      const substore: Store<any> = (child: any)\n      //eslint-disable-next-line no-unused-vars\n      const runCmd = <run runner={newValue => {}} />\n      runCmd.data.data.transactionContext = data => {\n        updates.push(state => {\n          const nextState = [...state]\n          nextState[key] = data\n          return nextState\n        })\n        return commit\n      }\n      stateNew[key] = substore.getState()\n      //$todo\n      forward({\n        from: substore,\n        to: {\n          graphite: {seq: runCmd},\n        },\n      })\n    }\n  }\n  const name = storeObjectArrayName(obj)\n  const store = storeFabric({\n    name,\n    currentState: stateNew,\n  })\n  //$todo\n  store.defaultShape = obj\n  store.on(updater, (_, payload) => payload)\n  return store\n}\n\nfunction createStoreObjectMap<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n> {\n  const state = Object.assign({}, obj)\n  const stateNew = Object.assign({}, obj)\n\n  const updater: any = createEvent('update ' + Math.random().toString())\n\n  let updates: Array<(state: any) => any> = []\n  const committer = () => {\n    updates = []\n    return () => {\n      let current = store.getState()\n      for (const fn of updates) {\n        current = fn(current)\n      }\n      commit = committer()\n      updater(current)\n    }\n  }\n  let commit = committer()\n  for (const [key, child] of Object.entries(state)) {\n    const substore: Store<any> = (child: any)\n    if (substore.kind !== Kind.store) continue\n    //eslint-disable-next-line no-unused-vars\n    const runCmd = <run runner={newValue => {}} />\n    runCmd.data.data.transactionContext = data => {\n      updates.push(state =>\n        Object.assign({}, state, {\n          [key]: data,\n        }),\n      )\n      return commit\n    }\n    stateNew[key] = substore.getState()\n    //$todo\n    forward({\n      from: substore,\n      to: {\n        graphite: {seq: runCmd},\n      },\n    })\n  }\n  //$todo\n  const name = storeObjectName(obj)\n  const store = storeFabric({\n    name,\n    currentState: stateNew,\n  })\n  //$todo\n  store.defaultShape = obj\n  store.on(updater, (_, payload) => payload)\n  return store\n}\n\ndeclare export function createStoreObject<\n  State: $ReadOnlyArray<Store<any> | any>,\n>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function createStoreObject<\n  State: {-[key: string]: Store<any> | any},\n>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function createStoreObject(obj: *) {\n  if (Array.isArray(obj)) {\n    return createStoreArray(obj)\n  }\n  return createStoreObjectMap(obj)\n}\n//eslint-disable-next-line\ndeclare export function extract<\n  State: $ReadOnlyArray<Store<any> | any>,\n  NextState: $ReadOnlyArray<Store<any> | any>,\n>(\n  store: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $TupleMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function extract<\n  State: {-[key: string]: Store<any> | any},\n  NextState: {-[key: string]: Store<any> | any},\n>(\n  obj: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $ObjMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function extract(store: Store<any>, extractor: any => any) {\n  let result\n  if ('defaultShape' in store) result = extractor((store: any).defaultShape)\n  else result = extractor((store: any).defaultState)\n  return createStoreObject(result)\n}\n","//@flow\nimport type {Event} from 'effector/event'\nimport type {Effect} from 'effector/effect'\nimport type {Store} from './index.h'\nimport {createStore} from './createStore'\n\nexport function restoreObject<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n> {\n  const result = {}\n  for (const [key, value] of Object.entries(obj)) {\n    result[key] = createStore(value)\n  }\n  return result\n}\n\nexport function restoreEffect<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done> {\n  const store = createStore(defaultState)\n  store.on(event.done, (_, {result}) => result)\n  return store\n}\n\nexport function restoreEvent<E>(event: Event<E>, defaultState: E): Store<E> {\n  const store = createStore(defaultState)\n  store.on(event, (_, v) => v)\n  return store\n}\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function restore<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done>\ndeclare export function restore<E>(event: Event<E>, defaultState: E): Store<E>\ndeclare export function restore<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n>\n\nconst visitorRestore = {\n  store: ({obj}) => obj,\n  event: ({obj, defaultState}) => restoreEvent(obj, defaultState),\n  effect: ({obj, defaultState}) => restoreEffect(obj, defaultState),\n  __: ({obj}) => restoreObject(obj),\n}\n\nexport function restore(obj: any, defaultState: any): any {\n  return visitorRestore[String(obj?.kind || '__')]({\n    obj,\n    defaultState,\n  })\n}\n","//@flow\n\nimport warning from 'warning'\nimport type {Effect} from './index.h'\nimport {Kind} from 'effector/stdlib'\n\nimport {eventFabric, type Event} from 'effector/event'\nimport type {CompositeName} from '../compositeName'\nimport {exec} from './exec'\nimport {callbacks} from './callbacks'\n\nexport function effectFabric<Payload, Done>({\n  name,\n  domainName,\n  parent,\n  handler,\n}: {\n  name?: string,\n  domainName: string,\n  parent?: CompositeName,\n  handler?: (payload: Payload) => Promise<Done> | Done,\n}): Effect<Payload, Done, *> {\n  //$off\n  const instance: Effect<Payload, Done, any> = eventFabric({\n    name,\n    parent,\n  })\n\n  const eventCreate = instance.create\n  const done: Event<{params: Payload, result: Done}> = eventFabric({\n    name: '' + instance.shortName + ' done',\n    parent,\n  })\n  const fail: Event<{params: Payload, error: *}> = eventFabric({\n    name: '' + instance.shortName + ' fail',\n    parent,\n  })\n\n  instance.done = done\n  instance.fail = fail\n  ;(instance: any).use = fn => {\n    thunk = fn\n    return instance\n  }\n  ;(instance: any).use.getCurrent = (): any => thunk\n  ;(instance: any).kind = Kind.effect\n  ;(instance: any).create = (params: Payload, fullName, args) => {\n    eventCreate(params, instance.getType(), args)\n    return exec(\n      params,\n      callbacks(thunk, result => void done(result), error => void fail(error)),\n    )\n  }\n  //eslint-disable-next-line no-unused-vars\n  let thunk: Function = handler || defaultThunk.bind(instance)\n\n  return instance\n}\n//eslint-disable-next-line no-unused-vars\nfunction defaultThunk(value) {\n  warning(false, 'no thunk used in %s', this.getType())\n  return Promise.resolve()\n}\n","//@noflow\n/* eslint-disable */\nimport {__DEV__, __DEBUG__} from 'effector/flags'\n\nvar invariant = function(condition) {\n  if (!condition) {\n    var error = new Error(\n      'Minified exception occurred; use the non-minified dev environment ' +\n      'for the full error message and additional helpful warnings.'\n    );\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nif (__DEV__) {\n  invariant = function(condition, format, a, b, c, d, e, f) {\n    if (__DEBUG__) {\n      if (format === undefined) {\n        throw new Error('invariant requires an error message argument');\n      }\n    }\n    if (!condition) {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      var error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n      error.framesToPop = 1; // we don't care about invariant's own frame\n      throw error;\n    }\n  }\n}\n\nexport default invariant\n","/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n","export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n","//@flow\n\n//prettier-ignore\nexport opaque type kind: string =\n  | 'none'\n  | 'store'\n  | 'event'\n  | 'effect'\n\nexport const Kind: {\n  +none: kind,\n  +store: kind,\n  +event: kind,\n  +effect: kind,\n} = {\n  none: 'none',\n  store: 'store',\n  event: 'event',\n  effect: 'effect',\n}\n","//@flow\n\nexport const stringRefcount = (): (() => string) => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n","//@flow\n\nimport {__DEV__} from 'effector/flags'\nimport type {CompositeName} from '../compositeName'\nimport {getDisplayName} from 'effector/store'\n\ntype StoreMeasurementPhase = 'map' | 'subscribe'\n\nlet currentPhase: StoreMeasurementPhase | null = null\nlet currentPhaseStore: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n} | null = null\n\nconst effectorEmoji = '\\u2604'\n\nconst supportsUserTiming =\n  typeof performance !== 'undefined'\n  && typeof performance.mark === 'function'\n  && typeof performance.clearMarks === 'function'\n  && typeof performance.measure === 'function'\n  && typeof performance.clearMeasures === 'function'\n\nconst enableUserTimingAPI = __DEV__\n\nfunction formatMarkName(markName: string) {\n  return `${effectorEmoji} ${markName}`\n}\n\nconst formatLabel = (label: string, warning: string | null) => {\n  const prefix = `${effectorEmoji} `\n  const suffix = warning ? ` Warning: ${warning}` : ''\n  return `${prefix}${label}${suffix}`\n}\n\nfunction getStoreLabel(storeName: string, phase: StoreMeasurementPhase) {\n  return `${storeName}.${phase}`\n}\n\nfunction getStoreMarkName(label: string, debugID: string) {\n  return `${label} (#${debugID})`\n}\n\nfunction beginMark(markName: string) {\n  performance.mark(formatMarkName(markName))\n}\n\nfunction clearMark(markName: string) {\n  performance.clearMarks(formatMarkName(markName))\n}\n\nfunction endMark(label: string, markName: string, warning: string | null) {\n  const formattedMarkName = formatMarkName(markName)\n  const formattedLabel = formatLabel(label, warning)\n  try {\n    performance.measure(formattedLabel, formattedMarkName)\n  } catch (err) {}\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName)\n  performance.clearMeasures(formattedLabel)\n}\n\nfunction beginStoreMark(store, phase: StoreMeasurementPhase) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  beginMark(markName)\n  return true\n}\n\nfunction clearStoreMark(store, phase: StoreMeasurementPhase) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  clearMark(markName)\n}\n\nfunction endStoreMark(\n  store,\n  phase: StoreMeasurementPhase,\n  warning: string | null,\n) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  endMark(label, markName, warning)\n}\n\nconst clearPendingPhaseMeasurement = () => {\n  if (currentPhase !== null && currentPhaseStore !== null) {\n    clearStoreMark(currentPhaseStore, currentPhase)\n  }\n  currentPhaseStore = null\n  currentPhase = null\n  //hasScheduledUpdateInCurrentPhase = false\n}\n\nexport function startPhaseTimer(\n  store: {\n    compositeName?: CompositeName,\n    domainName?: CompositeName,\n    /*::+*/ id: string,\n    /*::...*/\n  },\n  phase: StoreMeasurementPhase,\n): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return\n    }\n    clearPendingPhaseMeasurement()\n    if (!beginStoreMark(store, phase)) {\n      return\n    }\n    currentPhaseStore = store\n    currentPhase = phase\n  }\n}\n\nexport function stopPhaseTimer(warning: string | null): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return\n    }\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      endStoreMark(currentPhaseStore, currentPhase, warning)\n    }\n    currentPhase = null\n    currentPhaseStore = null\n  }\n}\n","//@flow\n/* eslint-disable */\nimport {__DEV__, __DEBUG__} from 'effector/flags'\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function(/*::condition: any, format: string, args: any*/) {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    console.error(message);\n    // try {\n      // --- Welcome ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      // throw new Error(message);\n    // } catch (x) {}\n  }\n\n  warning = function(condition: any, format: string, args: any) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (__DEBUG__) {\n      if (format === undefined) {\n        throw new Error(\n            '`warning(condition, format, ...args)` requires a warning ' +\n            'message argument'\n        );\n      }\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nexport default warning;","//@flow\n\nimport type {Callbacks} from './index.h'\n\nexport const exec = <Args, Done, Fail>(\n  args: Args,\n  cbs: Callbacks<Args, Done, Fail>,\n): Promise<Done> => {\n  declare var throwSymbol: Fail\n  declare var doneSymbol: Promise<Done> & Done\n  let syncError: Fail /*:: = throwSymbol*/\n  let req: Promise<Done> | Done /*:: = doneSymbol*/\n  let successSync = false\n  let fpromise\n  try {\n    req = cbs[2](args)\n    successSync = true\n  } catch (err) {\n    syncError = err\n  }\n  if (successSync === false) {\n    fpromise = Promise.reject(syncError)\n    //TODO deprecate this\n    //$off\n    fpromise.cache = () => undefined\n    const anyway = Promise.resolve(undefined)\n    //$off\n    fpromise.anyway = () => anyway\n    cbs[1]({params: args, error: syncError})\n    return fpromise\n  }\n  if (\n    typeof req === 'object'\n    && req !== null\n    && typeof req.then === 'function'\n  ) {\n    const then: Promise<Done> = (req: any)\n    fpromise = then.then(\n      result => {\n        //$off\n        fpromise.cache = () => result\n        cbs[0]({params: args, result})\n        return result\n      },\n      error => {\n        cbs[1]({params: args, error})\n        throw error\n      },\n    )\n    const anyway = fpromise.then(() => {}, () => {})\n    //$off\n    fpromise.anyway = () => anyway\n    return fpromise\n  }\n  const done: Done = (req: any)\n  fpromise = Promise.resolve(done)\n  //$off\n  fpromise.cache = () => done\n  const anyway = Promise.resolve(undefined)\n  //$off\n  fpromise.anyway = () => anyway\n  cbs[0]({params: args, result: done})\n  return fpromise\n}\n","//@flow\n\nconst cbDone = function(value: any) {\n  const cb = this[3]\n  this.length = 0\n  cb(value)\n}\nconst cbFail = function(value: any) {\n  const cb = this[4]\n  this.length = 0\n  cb(value)\n}\n\nexport const callbacks = (\n  thunk: Function,\n  onDone: (_: *) => void,\n  onFail: (_: *) => void,\n): any => [cbDone, cbFail, thunk, onDone, onFail]\n","//@flow\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {Store} from 'effector/store'\nimport {type Event, eventFabric} from 'effector/event'\nimport type {Effect} from 'effector/effect'\nimport type {CompositeName} from '../compositeName'\nexport class DomainHistory {\n  /*::;+*/ events: Set<Event<any>> = new Set()\n  /*::;+*/ effects: Set<Effect<any, any, any>> = new Set()\n  /*::;+*/ storages: Set<Store<any>> = new Set()\n  /*::;+*/ domains: Set<Domain> = new Set()\n}\n\nexport function domainHooks(\n  history: DomainHistory,\n  compositeName: CompositeName,\n  parentHooks?: DomainHooks,\n) {\n  let hooks: {\n    domain: Event<Domain>,\n    effect: Event<Effect<any, any, any>>,\n    event: Event<Event<any>>,\n    store: Event<any>,\n  }\n  if (parentHooks) {\n    hooks = childDomainHooks(parentHooks)\n  } else {\n    hooks = singleDomainHooks(compositeName)\n  }\n  hooks.domain.watch(domain => {\n    history.domains.add(domain)\n  })\n  hooks.event.watch(event => {\n    history.events.add(event)\n  })\n  hooks.store.watch(store => {\n    history.storages.add(store)\n  })\n  hooks.effect.watch(effect => {\n    history.effects.add(effect)\n  })\n  return hooks\n}\n\nconst singleDomainHooks = (compositeName: CompositeName) => {\n  const event: Event<Event<any>> = eventFabric({\n    name: `${compositeName.fullName} event hook`,\n    parent: compositeName,\n  })\n  const effect: Event<Effect<any, any, any>> = eventFabric({\n    name: `${compositeName.fullName} effect hook`,\n    parent: compositeName,\n  })\n  const store: Event<Store<any>> = eventFabric({\n    name: `${compositeName.fullName} store hook`,\n    parent: compositeName,\n  })\n  const domain: Event<Domain> = eventFabric({\n    parent: compositeName,\n  })\n  return {event, effect, store, domain}\n}\n\nconst childDomainHooks = (parentHooks: DomainHooks) => {\n  const event: Event<Event<any>> = parentHooks.event.prepend(_ => _)\n  const effect: Event<Effect<any, any, any>> = parentHooks.effect.prepend(\n    _ => _,\n  )\n  const store: Event<Store<any>> = parentHooks.store.prepend(_ => _)\n  const domain: Event<Domain> = parentHooks.domain.prepend(_ => _)\n  return {event, effect, store, domain}\n}\n","//@flow\n\nimport {stringRefcount} from 'effector/stdlib'\nimport {type Store, storeFabric} from 'effector/store'\nimport {type Event, eventFabric} from 'effector/event'\nimport {type Effect, effectFabric} from 'effector/effect'\n\nimport type {Domain, DomainHooks} from './index.h'\nimport {createName, type CompositeName} from '../compositeName'\nimport {DomainHistory, domainHooks} from './hook'\n\nconst nextID = stringRefcount()\n\nexport function domainFabric(\n  nameRaw?: string,\n  parent?: CompositeName,\n  parentHooks?: DomainHooks,\n): Domain {\n  const id = nextID()\n  const name = nameRaw || ''\n  const compositeName = createName(name, parent)\n  const history = new DomainHistory()\n  const hooks = domainHooks(history, compositeName, parentHooks)\n\n  return {\n    compositeName,\n    id,\n    getType() {\n      return compositeName.fullName\n    },\n    onCreateEvent(hook: (newEvent: Event<any>) => any) {\n      history.events.forEach(hook)\n      return hooks.event.watch(hook)\n    },\n    onCreateEffect(hook: (newEffect: Effect<any, any, any>) => any) {\n      history.effects.forEach(hook)\n      return hooks.effect.watch(hook)\n    },\n    onCreateStore(hook: (newStore: Store<any>) => any) {\n      history.storages.forEach(hook)\n      return hooks.store.watch(hook)\n    },\n    onCreateDomain(hook: (newDomain: Domain) => any) {\n      history.domains.forEach(hook)\n      return hooks.domain.watch(hook)\n    },\n    event<Payload>(name?: string): Event<Payload> {\n      const result = eventFabric({\n        name,\n        parent: compositeName,\n      })\n      hooks.event(result)\n      return result\n    },\n    effect<Params, Done, Fail>(name?: string): Effect<Params, Done, Fail> {\n      const result = effectFabric({\n        name,\n        domainName: compositeName.fullName,\n        parent: compositeName,\n      })\n      hooks.effect(result)\n      return result\n    },\n    domain(name?: string) {\n      const result = domainFabric(name, compositeName, hooks)\n      hooks.domain(result)\n      return result\n    },\n    store<T>(state: T): Store<T> {\n      const result = storeFabric({\n        currentState: state,\n        parent: compositeName,\n      })\n      hooks.store(result)\n      return result\n    },\n  }\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport {type Store, createStoreObject} from 'effector/store'\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function combine<R>(fn: () => R): Store<R>\ndeclare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): Store<R>\ndeclare export function combine<A, B, R>(\n  a: Store<A>,\n  b: Store<B>,\n  fn: (a: A, b: B) => R,\n): Store<R>\ndeclare export function combine<A, B, C, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  fn: (a: A, b: B, c: C) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  fn: (a: A, b: B, c: C, d: D) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  fn: (a: A, b: B, c: C, d: D, e: E) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  k: Store<K>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,\n): Store<R>\n\nexport function combine(...args: Array<Store<any>>): Store<any> {\n  invariant(args.length > 0, 'at least one argument required')\n  const handler: Function = (args[args.length - 1]: any)\n  const stores = args.slice(0, -1)\n  const structStore = createStoreObject(stores)\n\n  return structStore.map(list => handler(...list))\n}\n","//@flow\n\nimport {domainFabric} from './domainFabric'\n\nexport function createDomain(name?: string) {\n  return domainFabric(name === undefined ? '' : name)\n}\n","//@flow\n\nimport {effectFabric} from './effectFabric'\nimport type {Effect} from './index.h'\nexport function createEffect<Payload, Done>(\n  name?: string,\n  config?: {\n    handler?: (payload: Payload) => (Promise<Done> | Done),\n  }\n): Effect<Payload, Done, *> {\n  const opts = {}\n  opts.name = name\n  opts.domainName = ''\n  opts.handler = config?.handler\n  return effectFabric(opts)\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {type Event, createEvent} from 'effector/event'\n\ndeclare export function createApi<\n  S,\n  Obj: {-[name: string]: (store: S, e: any) => S},\n>(\n  store: Store<S>,\n  setters: Obj,\n): $ObjMap<Obj, <E>(h: (store: S, e: E) => S) => Event<E>>\n\nexport function createApi(store: Store<any>, setters: {[string]: Function}) {\n  const result = {}\n  for (const [key, handler] of Object.entries(setters)) {\n    const event = createEvent(key)\n    store.on(event, (handler: any))\n    result[key] = event\n  }\n  return result\n}\n"],"names":["typeDef","group","t","result","key","type","bind","data","id","nextID","this","createStateRef","current","toString","fx","tag","props","Cmd","Step","single","tag_","childrens","multi","seq","choose","loop","console","error","disposer","i","indexOf","splice","noopIndexOf","noopSplice","runStep","step","ctx","meta","stop","stepVisitor","tryRun","fn","call","arg","val","err","Name","shortName","fullName","path","createName","name","parent","undefined","length","concat","eventFabric","nameRaw","compositeName","makeName","graphite","fabric","instance","payload","args","create","getType","transactions","Ctx","emit","__stepArg","reg","isChanged","walkNode","walkEvent","kind","Kind","event","$$observable","watch","watcher","forward","from","to","runner","newValue","map","mapped","domainName","filter","prepend","contramapped","subscribe","observer","next","opts","toSeq","fromGraphite","push","createWatcher","child","createEvent","getDisplayName","store","setStoreName","rawName","getState","storeInstance","plainState","off","currentSubscription","subscribers","get","delete","on","handler","e","set","lastState","readName","eventOrFn","String","invariant","listener","lastCall","storeFabric","currentState","currentId","defaultState","updater","createDef","Map","setState","value","reduce","newResult","_","reset","firstState","lastResult","lastValue","innerStore","thru","dispatch","action","state","filterBeforeUpdate","createStore","createStoreObject","obj","Array","isArray","stateNew","Math","random","updates","committer","commit","substore","runCmd","transactionContext","nextState","arr","max","storeObjectMaxNames","maxLength","comma","storeObjectArrayName","defaultShape","createStoreArray","Object","assign","entries","keys","storeObjectName","createStoreObjectMap","restoreObject","restoreEffect","done","restoreEvent","v","effectFabric","eventCreate","fail","use","thunk","getCurrent","effect","params","exec","callbacks","warning","Promise","resolve","condition","Error","framesToPop","Symbol","self","window","global","module","Function","observable","ponyfill","none","stringRefcount","compute","run","update","unsubscribe","commonStepVisitor","command","cmd","transition","items","slice","steps","prev","runCtx","Boolean","newCtx","nextSteps","performance","mark","clearMarks","measure","def","visitorRestore","__","cbs","syncError","req","fpromise","successSync","reject","cache","anyway","then","cbDone","cb","cbFail","onDone","onFail","DomainHistory","events","Set","effects","storages","domains","list","domainFabric","parentHooks","history","hooks","domain","childDomainHooks","singleDomainHooks","add","domainHooks","onCreateEvent","hook","forEach","onCreateEffect","onCreateStore","onCreateDomain","config","extractor","setters"],"mappings":"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"}