{"version":3,"file":"effector.cjs.js","sources":["node_modules/effector/stdlib/typedef.js","node_modules/effector/stdlib/stateref.js","node_modules/effector/stdlib/fx.js","node_modules/effector/watcher/watcher.js","node_modules/effector/graphite/walk.js","node_modules/effector/compositeName.js","node_modules/effector/event/eventFabric.js","node_modules/effector/event/createEvent.js","node_modules/effector/store/staticMethods.js","node_modules/effector/store/setStoreName.js","node_modules/effector/perf/perf.js","node_modules/effector/store/storeMethods.js","node_modules/effector/store/storeFabric.js","node_modules/effector/store/createStore.js","node_modules/effector/store/createStoreObject.js","node_modules/effector/store/restore.js","node_modules/effector/effect/effectFabric.js","node_modules/effector/flags.prod.js","node_modules/effector/invariant/invariant.js","node_modules/effector/stdlib/kind.js","node_modules/effector/stdlib/refcount.js","node_modules/effector/warning/warning.js","node_modules/effector/effect/exec.js","node_modules/effector/effect/callbacks.js","node_modules/effector/domain/hook.js","node_modules/effector/domain/domainFabric.js","node_modules/effector/effector/combine.js","node_modules/effector/domain/createDomain.js","node_modules/effector/effect/createEffect.js","node_modules/effector/store/createApi.js"],"sourcesContent":["//@flow\nimport {stringRefcount} from './refcount'\nconst nextID = stringRefcount()\nexport type ID = string\nexport type TypeDef<+Type, +Group> = {\n  +id: ID,\n  +type: Type,\n  +group: Group,\n  +data: any,\n}\n\nexport type GraphiteMeta = {\n  +next: TypeDef<'multi', 'step'>,\n  +seq: TypeDef<'seq', 'step'>,\n}\n\nexport const Step = typeDef(('step': 'step'), {\n  single: null,\n  multi: null,\n  seq: null,\n  choose: null,\n  loop: null,\n})\n\nexport const Cmd = typeDef(('cmd': 'cmd'), {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null,\n})\n\nexport const Ctx = typeDef(('ctx': 'ctx'), {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null,\n})\n\n//eslint-disable-next-line no-unused-vars\ndeclare function typeDef<T: {+[key: string]: any}, Group>(\n  group: Group,\n  t: T,\n): $ObjMapi<T, <K>(k: K) => (data: any) => TypeDef<K, Group>>\nfunction typeDef(group, t) {\n  const result = {}\n  for (const key in t) {\n    result[key] = type.bind({\n      key,\n      group,\n    })\n  }\n  return result\n}\nfunction type(data) {\n  return {\n    id: nextID(),\n    type: this.key,\n    group: this.group,\n    data,\n  }\n}\n","//@flow\nimport type {ID} from './typedef'\nlet id = 0\n\nexport type StateRef = {\n  +id: ID,\n  current: any,\n}\n\nexport function createStateRef(current: any): StateRef {\n  return {\n    id: (++id).toString(36),\n    current,\n  }\n}\n","//@flow\n/* eslint-disable no-unused-vars */\n\nimport type {StateRef} from './stateref'\nimport {Step, Cmd, type TypeDef} from './typedef'\n\ntype Fun = TypeDef<*, 'step' | 'cmd'>\ntype Using = {\n  name: string,\n  reset?: any,\n}\n\n/* Step */\ndeclare export default function fx(\n  tag: 'loop',\n  props: {\n    branch: Fun,\n    iterator: Fun,\n    source: StateRef,\n    until: Using,\n    selector: Using,\n    item: Using,\n  },\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'loop', 'step'>\ndeclare export default function fx(\n  tag: 'choose',\n  props: {\n    state: StateRef,\n    selector: TypeDef<*, 'step'>,\n    cases: {+[key: string]: TypeDef<*, 'step'>},\n  },\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'choose', 'step'>\ndeclare export default function fx(\n  tag: 'single',\n  props: null,\n  childrens: *,\n): TypeDef<'single', 'step'>\ndeclare export default function fx(\n  tag: 'multi',\n  props: null,\n  ...childrens: *\n): TypeDef<'multi', 'step'>\ndeclare export default function fx(\n  tag: 'seq',\n  props: null,\n  ...childrens: *\n): TypeDef<'seq', 'step'>\n\n/* Cmd */\ndeclare export default function fx(\n  tag: 'compute',\n  props: {fn: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'compute', 'cmd'>\ndeclare export default function fx(\n  tag: 'emit',\n  props: {fullName: string},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'emit', 'cmd'>\ndeclare export default function fx(\n  tag: 'filter',\n  props: {filter: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'filter', 'cmd'>\ndeclare export default function fx(\n  tag: 'run',\n  props: {runner: *},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'run', 'cmd'>\ndeclare export default function fx(\n  tag: 'update',\n  props: {|store: StateRef|} | {|val: string|},\n  ...childrens: $ReadOnlyArray<void>\n): TypeDef<'update', 'cmd'>\nexport default function fx(\n  tag:\n    | 'choose'\n    | 'single'\n    | 'multi'\n    | 'seq'\n    | 'compute'\n    | 'emit'\n    | 'filter'\n    | 'run'\n    | 'update',\n  props: *,\n  ...childrens: *\n) {\n  if (tag in Cmd) {\n    const tag_: 'compute' | 'emit' | 'filter' | 'run' | 'update' = (tag: any)\n    return Step.single(Cmd[tag_](props))\n  }\n  const tag_: 'single' | 'multi' | 'seq' | 'choose' | 'loop' = (tag: any)\n  switch (tag_) {\n    case 'single':\n      return Step.single(childrens[0])\n    case 'multi':\n      return Step.multi(childrens)\n    case 'seq':\n      return Step.seq(childrens)\n    case 'choose':\n      return Step.choose(props)\n    case 'loop':\n      return Step.loop(props)\n  }\n  if (typeof tag === 'function') return tag(props, childrens)\n  console.error('unknown node \"%s\"', tag)\n  return null\n}\n","//@flow\n\nimport type {TypeDef, GraphiteMeta} from 'effector/stdlib'\nimport type {Watcher} from './index.h'\n\nconst noopIndexOf = () => -1\n//eslint-disable-next-line no-unused-vars\nconst noopSplice = (i: number, n: number) => []\n\nfunction disposer() {\n  const i = this.indexOf()\n  if (i === -1) return\n  this.splice(i, 1)\n  this.indexOf = noopIndexOf\n  this.splice = noopSplice\n}\n\nexport const createWatcher = (opts: {\n  child: TypeDef<*, 'cmd' | 'step'>,\n  parent: GraphiteMeta,\n}): Watcher => {\n  const subscribers = opts.parent.next.data\n  const instance = {\n    indexOf: subscribers.indexOf.bind(subscribers, opts.child),\n    splice: subscribers.splice.bind(subscribers),\n  }\n  const result = disposer.bind(instance)\n  result.unsubscribe = disposer.bind(instance)\n  return (result: $todo)\n}\n","//@flow\n\nimport type {Event} from 'effector/event'\nimport {type TypeDef, Ctx, type StateRef, createStateRef} from 'effector/stdlib'\nimport {__DEV__, __DEBUG__} from 'effector/flags'\nimport type {CommonCtx, Meta, Reg, Command} from './index.h'\n\nexport function walkEvent<T>(payload: T, event: Event<T>) {\n  walkNode(\n    event.graphite.seq,\n    Ctx.emit({\n      __stepArg: payload,\n    }),\n  )\n}\n\nexport function walkNode(seq: TypeDef<'seq', 'step'>, ctx: TypeDef<*, 'ctx'>) {\n  const meta = {\n    transactions: [],\n    stop: false,\n    ctx,\n    reg: {\n      isChanged: true,\n    },\n    val: {},\n  }\n  runStep(seq, meta.ctx, meta)\n  for (let i = 0; i < meta.transactions.length; i++) {\n    meta.transactions[i]()\n  }\n  meta.transactions.length = 0\n}\n\nfunction runStep(step, ctx: *, meta) {\n  meta.stop = false\n  stepVisitor[step.type](step, ctx, meta)\n}\n\nconst commonStepVisitor = {\n  single(step: TypeDef<'single', 'step'>, ctx: CommonCtx, meta: Meta) {\n    meta.arg = ctx.data.__stepArg\n    meta.ctx = command[step.data.type].cmd(step.data, meta)\n    meta.stop = !command[meta.ctx.type].transition(meta.reg)\n  },\n  multi(step, ctx, meta) {\n    const items = step.data.slice()\n    for (let i = 0; i < items.length; i++) {\n      runStep(items[i], ctx, meta)\n    }\n    meta.stop = false\n  },\n  seq(steps: TypeDef<'seq', 'step'>, prev: CommonCtx, meta) {\n    meta.ctx = prev\n    const items = steps.data.slice()\n    for (let i = 0; i < items.length; i++) {\n      runStep(items[i], meta.ctx, meta)\n      if (meta.stop) {\n        break\n      }\n    }\n  },\n}\nconst stepVisitor = {}\nstepVisitor.single = commonStepVisitor.single\nstepVisitor.multi = commonStepVisitor.multi\nstepVisitor.seq = commonStepVisitor.seq\n\nif (__DEBUG__) {\n  const LOOP_TIMEOUT = 5e3\n  const infiniteLoopProtection = start => {\n    if (Date.now() - start > LOOP_TIMEOUT) {\n      throw new Error('infinite loop protection')\n    }\n  }\n  const stepVisitorNext = {\n    loop(step: TypeDef<'loop', 'step'>, ctx: TypeDef<*, 'ctx'>, meta) {\n      const VAL = 'current'\n      type Fun = TypeDef<*, 'step'>\n      type Using = {\n        name: string,\n        reset?: any,\n      }\n      type StepData = {\n        branch: Fun,\n        iterator: Fun,\n        source: StateRef,\n        until: Using,\n        selector: Using,\n        item: Using,\n      }\n      const data: StepData = step.data\n      const branch: Fun = data.branch\n      const iterator: Fun = data.iterator\n\n      const source: StateRef = data.source\n      const until = using(data.until, meta)\n      const selector = using(data.selector, meta)\n      const item = using(data.item, meta)\n\n      const now = Date.now()\n\n      while (until[VAL]) {\n        if (__DEV__) {\n          infiniteLoopProtection(now)\n        }\n        item[VAL] = source[VAL][selector[VAL]]\n        runStep(branch, ctx, meta)\n        runStep(iterator, ctx, meta)\n      }\n\n      function using(opts, meta): StateRef {\n        const name = String(opts.name)\n        if ('reset' in opts) {\n          if (!(name in meta.val)) {\n            meta.val[name] = createStateRef(opts.reset)\n          }\n          meta.val[name][VAL] = opts.reset\n        }\n        return meta.val[name]\n      }\n    },\n    choose(step: TypeDef<'choose', 'step'>, ctx: TypeDef<*, 'ctx'>, meta) {\n      type Cases = {+[key: string]: TypeDef<*, 'step'>}\n      const cases: Cases = step.data.cases\n      runStep(step.data.selector, ctx, meta)\n      const caseName = String(step.data.state.current)\n      let next\n      if (caseName in cases) {\n        next = cases[caseName]\n      } else if ('__' in cases) {\n        next = cases.__\n      } else {\n        console.error('no case \"%s\" exists', caseName)\n        return\n      }\n      runStep(next, ctx, meta)\n    },\n  }\n  stepVisitor.loop = stepVisitorNext.loop\n  stepVisitor.choose = stepVisitorNext.choose\n}\n\nconst command = ({\n  emit: {\n    cmd: (single, meta) =>\n      Ctx.emit({\n        __stepArg: meta.arg,\n      }),\n    transition: () => true,\n  },\n  filter: {\n    cmd(single, meta) {\n      const ctx = Ctx.filter({\n        __stepArg: meta.arg,\n      })\n      const runCtx = tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.filter,\n      })\n      meta.reg.isChanged = Boolean(runCtx.result)\n      return ctx\n    },\n    transition: reg => Boolean(reg.isChanged),\n  },\n  run: {\n    cmd(single, meta) {\n      const ctx = Ctx.run({})\n\n      if ('transactionContext' in single.data)\n        meta.transactions.push(single.data.transactionContext(meta.arg))\n      tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.runner,\n      })\n      return ctx\n    },\n    transition: () => false,\n  },\n  update: {\n    cmd(single, meta) {\n      let store\n      if ('val' in single.data) {\n        store = meta.val[single.data.val] =\n          meta.val[single.data.val] || createStateRef(null)\n      } else {\n        store = single.data.store\n      }\n      store.current = meta.arg\n      return Ctx.update({\n        __stepArg: meta.arg,\n      })\n    },\n    transition: () => true,\n  },\n  compute: {\n    cmd(single, meta) {\n      const newCtx = Ctx.compute({\n        __stepArg: null,\n      })\n      const runCtx = tryRun({\n        err: false,\n        result: (null: any),\n        arg: meta.arg,\n        val: meta.val,\n        fn: single.data.fn,\n      })\n      meta.reg.isChanged = !runCtx.err && runCtx.result !== undefined\n      if (!runCtx.err) {\n        newCtx.data.__stepArg = runCtx.result\n      }\n      return newCtx\n    },\n    transition: reg => Boolean(reg.isChanged),\n  },\n}: {\n  emit: Command<'emit'>,\n  filter: Command<'filter'>,\n  run: Command<'run'>,\n  update: Command<'update'>,\n  compute: Command<'compute'>,\n})\n\nfunction tryRun(ctx) {\n  try {\n    ctx.result = ctx.fn.call(null, ctx.arg, ctx.val)\n  } catch (err) {\n    console.error(err)\n    ctx.err = true\n  }\n  return ctx\n}\n","//@flow\n\nexport type CompositeName = {\n  +shortName: string,\n  +fullName: string,\n  +path: Array<string>,\n}\n\nfunction Name(shortName: string, fullName: string, path: Array<string>) {\n  this.shortName = shortName\n  this.fullName = fullName\n  this.path = path\n}\n\nexport function createName(name: string, parent?: CompositeName) {\n  let path\n  let fullName\n  const shortName = name\n  if (parent === undefined) {\n    if (name.length === 0) {\n      path = ([]: string[])\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    if (name.length === 0) {\n      path = parent.path\n      fullName = parent.fullName\n    } else {\n      path = parent.path.concat([name])\n      if (parent.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + parent.fullName + '/' + name\n      }\n    }\n  }\n  return new Name(shortName, fullName, path)\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n\nimport {\n  //eslint-disable-next-line no-unused-vars\n  fx,\n  Kind,\n  stringRefcount,\n  type GraphiteMeta,\n  type TypeDef,\n} from 'effector/stdlib'\nimport {createWatcher} from 'effector/watcher'\nimport type {Effect} from 'effector/effect'\nimport {walkEvent} from 'effector/graphite'\n\nimport type {Subscription} from '../effector/index.h'\nimport type {Event} from './index.h'\nimport {type CompositeName, createName} from '../compositeName'\n\nconst nextID = stringRefcount()\n\nexport function eventFabric<Payload>({\n  name: nameRaw,\n  parent,\n}: {\n  name?: string,\n  parent?: CompositeName,\n}): Event<Payload> {\n  const id = nextID()\n  const name = nameRaw || id\n  const fullName = makeName(name, parent)\n  const compositeName = createName(name, parent)\n  const graphite = fabric({\n    fullName,\n  })\n\n  //$off\n  const instance: Event<Payload> = (\n    payload: Payload,\n    ...args: any[]\n  ): Payload => instance.create(payload, fullName, args)\n  ;(instance: any).getType = () => compositeName.fullName\n  //eslint-disable-next-line no-unused-vars\n  ;(instance: any).create = (payload, fullName, args) => {\n    walkEvent(payload, instance)\n    return payload\n  }\n  ;(instance: any).kind = Kind.event\n  ;(instance: any)[$$observable] = () => instance\n  ;(instance: any).id = id\n  ;(instance: any).watch = watchEvent.bind(null, instance)\n  ;(instance: any).map = mapEvent.bind(null, instance)\n  ;(instance: any).filter = filterEvent.bind(null, instance)\n  ;(instance: any).prepend = prepend.bind(null, instance)\n  ;(instance: any).subscribe = subscribe.bind(null, instance)\n  instance.graphite = graphite\n  instance.shortName = name\n  instance.domainName = parent\n  instance.compositeName = compositeName\n\n  return instance\n}\n\nfunction subscribe(event, observer): Subscription {\n  return event.watch(payload => observer.next(payload))\n}\n\nfunction prepend(event, fn: (_: any) => *) {\n  const contramapped: Event<any> = eventFabric({\n    name: '* → ' + event.shortName,\n    parent: event.domainName,\n  })\n  forward({\n    from: contramapped,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            {event.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return contramapped\n}\n\ndeclare function mapEvent<A, B>(event: Event<A>, fn: (_: A) => B): Event<B>\ndeclare function mapEvent<A, B>(\n  effect: Effect<A, any, any>,\n  fn: (_: A) => B,\n): Event<B>\nfunction mapEvent<A, B>(event: Event<A> | Effect<A, any, any>, fn: A => B) {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' → *',\n    parent: event.domainName,\n  })\n  forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            {mapped.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return mapped\n}\n\nfunction filterEvent<A, B>(\n  event: Event<A> | Effect<A, any, any>,\n  fn: A => B | void,\n): Event<B> {\n  const mapped = eventFabric({\n    name: '' + event.shortName + ' →? *',\n    parent: event.domainName,\n  })\n  forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute fn={newValue => fn(newValue)} />\n            <filter filter={result => result !== undefined} />\n            {mapped.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return mapped\n}\n\nfunction watchEvent<Payload>(\n  event: Event<Payload>,\n  watcher: (payload: Payload, type: string) => any,\n): Subscription {\n  return forward({\n    from: event,\n    to: {\n      graphite: {\n        seq: ((\n          <run\n            runner={(newValue: Payload) => watcher(newValue, event.getType())}\n          />\n        ): $todo),\n      },\n    },\n  })\n}\nfunction makeName(name: string, compositeName?: CompositeName) {\n  const fullName = compositeName?.fullName\n  if (!fullName) {\n    if (!name) return ''\n    return name\n  }\n  return '' + fullName + '/' + name\n}\ntype Graphiter = {\n  +graphite: GraphiteMeta,\n  /*::...*/\n}\ntype GraphiterSmall = {\n  +graphite: {\n    +seq: TypeDef<'seq' | 'loop', 'step'>,\n    /*::...*/\n  },\n  /*::...*/\n}\n\nexport function forward(opts: {\n  from: Graphiter,\n  to: GraphiterSmall,\n}): Subscription {\n  const toSeq = opts.to.graphite.seq\n  const fromGraphite = opts.from.graphite\n  fromGraphite.next.data.push(toSeq)\n  return createWatcher({\n    child: toSeq,\n    parent: fromGraphite,\n  })\n}\n\nconst fabric = (args: {fullName: string}): GraphiteMeta => {\n  const nextSteps = <multi />\n  return {\n    next: nextSteps,\n    seq: (\n      <seq>\n        <emit fullName={args.fullName} />\n        {nextSteps}\n      </seq>\n    ),\n  }\n}\n","//@flow\n\nimport {eventFabric} from './eventFabric'\nimport type {Event} from './index.h'\n\nexport function createEvent<Payload>(name?: string): Event<Payload> {\n  return eventFabric({\n    name,\n  })\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport type {CompositeName} from '../compositeName'\n\nexport function withProps<R, S, P>(\n  store: Store<S>,\n  handler: (store: S, props: P) => R,\n): (props: P) => R {\n  return (props: P) => handler(store.getState(), props)\n}\nexport function getDisplayName(store: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (store.compositeName) {\n    return store.compositeName.fullName\n  }\n  if (store.domainName) {\n    return store.domainName.fullName\n  }\n  return store.id\n}\n","//@flow\n\nimport {Kind} from 'effector/stdlib'\nimport {__DEBUG__} from 'effector/flags'\nimport type {Store} from './index.h'\nimport {getDisplayName} from './staticMethods'\nimport {createName} from '../compositeName'\n\nconst storeObjectMaxNames = 25\n\nexport function storeObjectArrayName(arr: $ReadOnlyArray<Store<any> | any>) {\n  let i = 0\n  const max = storeObjectMaxNames - 1\n  const maxLength = arr.length - 1\n  let name = 'combine('\n  for (const store of arr) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    if (store.kind !== Kind.store) {\n      name += store.toString() + comma\n    } else {\n      name += getDisplayName(store) + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n\nexport function storeObjectName(obj: {[key: string]: Store<any> | any}) {\n  let i = 0\n  const keys = Object.keys(obj)\n  const max = storeObjectMaxNames - 1\n  const maxLength = keys.length - 1\n  let name = 'combine('\n  for (const key in obj) {\n    const comma = i === max || maxLength === i ? '' : ', '\n    const store = obj[key]\n    if (store.kind !== Kind.store) {\n      name += store.toString() + comma\n    } else {\n      name += getDisplayName(store) + comma\n    }\n    i += 1\n    if (comma === '') break\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, store.domainName)\n  store.shortName = rawName\n  store.compositeName = compositeName\n}\n\nfunction isStoreObject(store: Store<any>) {\n  return (\n    typeof store.kind !== 'undefined'\n    && store.kind === Kind.store\n    //$todo\n    && typeof store.defaultShape !== 'undefined'\n  )\n}\n\nexport function storeNaming<Obj: {[key: string]: Store<any> | Object}>(\n  object: Obj,\n  parent?: Store<any>,\n) {\n  const entries: Array<[string, Store<any>]> = (Object.entries(object): any)\n  for (const [storeName, store] of entries) {\n    if (parent && store.kind === Kind.store) {\n      store.domainName = parent.compositeName || store.domainName\n    }\n\n    if (isStoreObject(store)) {\n      setStoreName(store, storeName)\n      //$todo\n      storeNaming(store.defaultShape, store)\n      continue\n    }\n\n    if (store.kind === Kind.store) {\n      setStoreName(store, storeName)\n      continue\n    }\n\n    if (__DEBUG__)\n      console.warn(\n        'effector: Key \"%s\" must be store but instead received %s',\n        storeName,\n        store.kind || '\"' + typeof store + '\"',\n        store,\n      )\n  }\n}\n","//@flow\n\nimport {__DEV__} from 'effector/flags'\nimport type {CompositeName} from '../compositeName'\nimport {getDisplayName} from 'effector/store'\n\ntype StoreMeasurementPhase = 'map' | 'subscribe'\n\nlet currentPhase: StoreMeasurementPhase | null = null\nlet currentPhaseStore: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n} | null = null\n\nconst effectorEmoji = '\\u2604'\n\nconst supportsUserTiming =\n  typeof performance !== 'undefined'\n  && typeof performance.mark === 'function'\n  && typeof performance.clearMarks === 'function'\n  && typeof performance.measure === 'function'\n  && typeof performance.clearMeasures === 'function'\n\nconst enableUserTimingAPI = __DEV__\n\nfunction formatMarkName(markName: string) {\n  return `${effectorEmoji} ${markName}`\n}\n\nconst formatLabel = (label: string, warning: string | null) => {\n  const prefix = `${effectorEmoji} `\n  const suffix = warning ? ` Warning: ${warning}` : ''\n  return `${prefix}${label}${suffix}`\n}\n\nfunction getStoreLabel(storeName: string, phase: StoreMeasurementPhase) {\n  return `${storeName}.${phase}`\n}\n\nfunction getStoreMarkName(label: string, debugID: string) {\n  return `${label} (#${debugID})`\n}\n\nfunction beginMark(markName: string) {\n  performance.mark(formatMarkName(markName))\n}\n\nfunction clearMark(markName: string) {\n  performance.clearMarks(formatMarkName(markName))\n}\n\nfunction endMark(label: string, markName: string, warning: string | null) {\n  const formattedMarkName = formatMarkName(markName)\n  const formattedLabel = formatLabel(label, warning)\n  try {\n    performance.measure(formattedLabel, formattedMarkName)\n  } catch (err) {}\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName)\n  performance.clearMeasures(formattedLabel)\n}\n\nfunction beginStoreMark(store, phase: StoreMeasurementPhase) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  beginMark(markName)\n  return true\n}\n\nfunction clearStoreMark(store, phase: StoreMeasurementPhase) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  clearMark(markName)\n}\n\nfunction endStoreMark(\n  store,\n  phase: StoreMeasurementPhase,\n  warning: string | null,\n) {\n  const componentName = getDisplayName(store)\n  const debugID = store.id\n  const label = getStoreLabel(componentName, phase)\n  const markName = getStoreMarkName(label, debugID)\n  endMark(label, markName, warning)\n}\n\nconst clearPendingPhaseMeasurement = () => {\n  if (currentPhase !== null && currentPhaseStore !== null) {\n    clearStoreMark(currentPhaseStore, currentPhase)\n  }\n  currentPhaseStore = null\n  currentPhase = null\n  //hasScheduledUpdateInCurrentPhase = false\n}\n\nexport function startPhaseTimer(\n  store: {\n    compositeName?: CompositeName,\n    domainName?: CompositeName,\n    /*::+*/ id: string,\n    /*::...*/\n  },\n  phase: StoreMeasurementPhase,\n): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return\n    }\n    clearPendingPhaseMeasurement()\n    if (!beginStoreMark(store, phase)) {\n      return\n    }\n    currentPhaseStore = store\n    currentPhase = phase\n  }\n}\n\nexport function stopPhaseTimer(warning: string | null): void {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return\n    }\n    if (currentPhase !== null && currentPhaseStore !== null) {\n      endStoreMark(currentPhaseStore, currentPhase, warning)\n    }\n    currentPhase = null\n    currentPhaseStore = null\n  }\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind} from 'effector/stdlib'\n\nimport invariant from 'invariant'\nimport {startPhaseTimer, stopPhaseTimer} from 'effector/perf'\n\nimport {forward, type Event} from 'effector/event'\nimport type {Store, ThisStore} from './index.h'\nimport type {Subscriber} from '../effector/index.h'\nimport type {CompositeName} from '../compositeName'\n\nexport function reset(storeInstance: ThisStore, event: Event<any>) {\n  return on.call(this, storeInstance, event, () => storeInstance.defaultState)\n}\nexport function getState(storeInstance: ThisStore) {\n  return storeInstance.plainState.current\n}\nexport function off(storeInstance: ThisStore, event: Event<any>) {\n  const currentSubscription = storeInstance.subscribers.get(event)\n  if (currentSubscription === undefined) return\n  currentSubscription()\n  storeInstance.subscribers.delete(event)\n}\nconst readName = (e: *): string => {\n  switch (e.kind) {\n    case Kind.store:\n      return e.shortName\n    default:\n      return e.getType()\n  }\n}\nexport function on(storeInstance: ThisStore, event: any, handler: Function) {\n  const e: Event<any> = event\n  storeInstance.subscribers.set(\n    e,\n    forward({\n      from: e,\n      to: {\n        graphite: {\n          seq: (\n            <seq>\n              <compute\n                fn={newValue => {\n                  const lastState = getState(storeInstance)\n                  return handler(lastState, newValue, readName(e))\n                }}\n              />\n              <filter\n                filter={data => {\n                  const lastState = getState(storeInstance)\n                  return data !== lastState && data !== undefined\n                }}\n              />\n              {storeInstance.graphite.seq}\n            </seq>\n          ),\n        },\n      },\n    }),\n  )\n  return this\n}\nexport function observable(storeInstance: ThisStore) {\n  const result = {\n    subscribe(observer: Subscriber<any>) {\n      invariant(\n        typeof observer === 'object' && observer !== null,\n        'Expected the observer to be an object.',\n      )\n\n      function observeState(state) {\n        if (observer.next) {\n          observer.next(state)\n        }\n      }\n      return subscribe(storeInstance, observeState)\n    },\n  }\n  //$off\n  result[$$observable] = function() {\n    return this\n  }\n  return result\n}\nexport function watch(\n  storeInstance: ThisStore,\n  eventOrFn: Event<*> | Function,\n  fn?: Function,\n) {\n  const kind = String(eventOrFn?.kind || '__')\n  switch (kind) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      invariant(typeof fn === 'function', 'watch requires function handler')\n      return eventOrFn.watch(payload =>\n        //$todo\n        fn(getState(storeInstance), payload, readName(eventOrFn)),\n      )\n    case '__':\n    default:\n      invariant(\n        typeof eventOrFn === 'function',\n        'watch requires function handler',\n      )\n      return subscribe(storeInstance, eventOrFn)\n  }\n}\nexport function subscribe(storeInstance: ThisStore, listener: Function) {\n  invariant(\n    typeof listener === 'function',\n    'Expected the listener to be a function',\n  )\n  let stopPhaseTimerMessage = null\n  let lastCall = getState(storeInstance)\n\n  startPhaseTimer(storeInstance, 'subscribe')\n  try {\n    listener(lastCall)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n    stopPhaseTimerMessage = 'Got initial error'\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n\n  return forward({\n    from: storeInstance,\n    to: {\n      graphite: {\n        seq: (\n          //$todo\n          <run\n            runner={args => {\n              let stopPhaseTimerMessage = null\n              startPhaseTimer(storeInstance, 'subscribe')\n              if (args === lastCall) {\n                stopPhaseTimer(stopPhaseTimerMessage)\n                return\n              }\n              lastCall = args\n              try {\n                listener(args)\n              } catch (err) {\n                console.error(err)\n                stopPhaseTimerMessage = 'Got error'\n              }\n              stopPhaseTimer(stopPhaseTimerMessage)\n            }}\n          />\n        ),\n      },\n    },\n  })\n}\nexport function thru(fn: Function) {\n  return fn(this)\n}\nexport function dispatch(action: any) {\n  return action\n}\n\nexport function getDisplayName(store: {\n  compositeName?: CompositeName,\n  domainName?: CompositeName,\n  /*::+*/ id: string,\n  /*::...*/\n}) {\n  if (store.compositeName) {\n    return store.compositeName.fullName\n  }\n  if (store.domainName) {\n    return store.domainName.fullName\n  }\n  return store.id\n}\n\nexport function mapStore<A, B>(\n  store: Store<A>,\n  fn: (state: A, lastState?: B) => B,\n  firstState?: B,\n): Store<B> {\n  startPhaseTimer(store, 'map')\n  let lastValue = store.getState()\n  let lastResult\n  let stopPhaseTimerMessage = null\n  try {\n    lastResult = fn(lastValue, firstState)\n    stopPhaseTimerMessage = 'Initial'\n  } catch (err) {\n    console.error(err)\n    stopPhaseTimerMessage = 'Got initial error'\n  }\n  stopPhaseTimer(stopPhaseTimerMessage)\n  const innerStore: Store<any> = this({\n    name: '' + store.shortName + ' → *',\n    currentState: lastResult,\n    parent: store.domainName,\n  })\n  forward({\n    from: store,\n    to: {\n      graphite: {\n        seq: (\n          <seq>\n            <compute\n              fn={newValue => {\n                startPhaseTimer(store, 'map')\n                lastValue = newValue\n                let stopPhaseTimerMessage = null\n                const lastState = innerStore.getState()\n                let result\n                try {\n                  result = fn(newValue, lastState)\n                } catch (err) {\n                  console.error(err)\n                  stopPhaseTimerMessage = 'Got error'\n                }\n                stopPhaseTimer(stopPhaseTimerMessage)\n                return result\n              }}\n            />\n            <filter\n              filter={result => {\n                const lastState = innerStore.getState()\n                const isChanged = result !== lastState && result !== undefined\n                if (isChanged) {\n                  lastResult = result\n                }\n                stopPhaseTimer(null)\n                return isChanged\n              }}\n            />\n            {innerStore.graphite.seq}\n          </seq>\n        ),\n      },\n    },\n  })\n  return innerStore\n}\n","//@flow\n//@jsx fx\nimport $$observable from 'symbol-observable'\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind, createStateRef} from 'effector/stdlib'\nimport {createEvent} from 'effector/event'\n\nimport type {Store, ThisStore} from './index.h'\nimport {setStoreName} from './setStoreName'\nimport type {CompositeName} from '../compositeName'\nimport {\n  reset,\n  getState,\n  off,\n  on,\n  observable,\n  watch,\n  subscribe,\n  thru,\n  dispatch,\n  mapStore,\n} from './storeMethods'\n\nexport function storeFabric<State>(props: {\n  currentState: State,\n  name?: string,\n  parent?: CompositeName,\n}): Store<State> {\n  const {currentState, name, parent} = props\n  const plainState = createStateRef(currentState)\n  const currentId = plainState.id\n  const defaultState = currentState\n\n  const updater: any = createEvent('update ' + currentId)\n  const storeInstance: ThisStore = {\n    graphite: createDef(plainState),\n    kind: Kind.store,\n    id: currentId,\n    shortName: currentId,\n    domainName: parent,\n    defaultState,\n    plainState,\n    subscribers: new Map(),\n  }\n  //TODO fix type\n  //$off\n  if (name) setStoreName(storeInstance, name)\n  const store: $Shape<Store<State>> = {\n    graphite: storeInstance.graphite,\n    kind: Kind.store,\n    id: currentId,\n    shortName: currentId,\n    domainName: parent,\n    setState,\n    off: off.bind(null, storeInstance),\n    watch: watch.bind(null, storeInstance),\n    subscribe: subscribe.bind(null, storeInstance),\n    getState: getState.bind(null, storeInstance),\n  }\n  ;(store: any).reset = reset.bind(store, storeInstance)\n  ;(store: any).on = on.bind(store, storeInstance)\n  ;(store: any).defaultState = defaultState\n  ;(store: any).map = mapStore.bind(storeFabric, store)\n  ;(store: any).thru = thru.bind(store)\n  ;(store: any).dispatch = dispatch.bind(null)\n  //$off\n  store[$$observable] = observable.bind(null, storeInstance)\n  //TODO fix type\n  //$off\n  if (name) setStoreName(store, name)\n  store.on(updater, (_, payload) => payload)\n\n  function setState(value, reduce?: Function) {\n    const currentReducer =\n      typeof reduce === 'function' ? reduce : (_, payload) => payload\n    const state = getState(storeInstance)\n    const newResult = currentReducer(state, value)\n\n    updater(newResult)\n  }\n\n  return store\n}\n\nfunction filterBeforeUpdate(newValue) {\n  return newValue !== undefined && newValue !== this.current\n}\nconst createDef = plainState => {\n  const def = {}\n  def.next = <multi />\n  def.seq = (\n    <seq>\n      <filter filter={filterBeforeUpdate.bind(plainState)} />\n      <update store={plainState} />\n      {def.next}\n    </seq>\n  )\n  return def\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {storeFabric} from './storeFabric'\n\nexport function createStore<State>(state: State): Store<State> {\n  return storeFabric({\n    currentState: state,\n  })\n}\n","//@flow\n//@jsx fx\n//eslint-disable-next-line no-unused-vars\nimport {fx, Kind} from 'effector/stdlib'\n\nimport {createEvent, forward} from 'effector/event'\nimport type {Store} from './index.h'\nimport {storeObjectName, storeObjectArrayName} from './setStoreName'\nimport {storeFabric} from './storeFabric'\n\nfunction createStoreArray<State: $ReadOnlyArray<Store<any> | any>>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n> {\n  const state = [...obj]\n  const stateNew = [...obj]\n\n  const updater: any = createEvent('update ' + Math.random().toString())\n\n  let updates: Array<(state: any) => any> = []\n  const committer = () => {\n    updates = []\n    return () => {\n      let current = store.getState()\n      for (const fn of updates) {\n        current = fn(current)\n      }\n      commit = committer()\n      updater(current)\n    }\n  }\n  let commit = committer()\n  for (const [key, child] of state.map((e, i) => [i, e])) {\n    if (child.kind === Kind.store) {\n      const substore: Store<any> = (child: any)\n      //eslint-disable-next-line no-unused-vars\n      const runCmd = <run runner={newValue => {}} />\n      runCmd.data.data.transactionContext = data => {\n        updates.push(state => {\n          const nextState = [...state]\n          nextState[key] = data\n          return nextState\n        })\n        return commit\n      }\n      stateNew[key] = substore.getState()\n      //$todo\n      forward({\n        from: substore,\n        to: {\n          graphite: {seq: runCmd},\n        },\n      })\n    }\n  }\n  const name = storeObjectArrayName(obj)\n  const store = storeFabric({\n    name,\n    currentState: stateNew,\n  })\n  //$todo\n  store.defaultShape = obj\n  store.on(updater, (_, payload) => payload)\n  return store\n}\n\nfunction createStoreObjectMap<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n> {\n  const state = Object.assign({}, obj)\n  const stateNew = Object.assign({}, obj)\n\n  const updater: any = createEvent('update ' + Math.random().toString())\n\n  let updates: Array<(state: any) => any> = []\n  const committer = () => {\n    updates = []\n    return () => {\n      let current = store.getState()\n      for (const fn of updates) {\n        current = fn(current)\n      }\n      commit = committer()\n      updater(current)\n    }\n  }\n  let commit = committer()\n  for (const [key, child] of Object.entries(state)) {\n    const substore: Store<any> = (child: any)\n    if (substore.kind !== Kind.store) continue\n    //eslint-disable-next-line no-unused-vars\n    const runCmd = <run runner={newValue => {}} />\n    runCmd.data.data.transactionContext = data => {\n      updates.push(state =>\n        Object.assign({}, state, {\n          [key]: data,\n        }),\n      )\n      return commit\n    }\n    stateNew[key] = substore.getState()\n    //$todo\n    forward({\n      from: substore,\n      to: {\n        graphite: {seq: runCmd},\n      },\n    })\n  }\n  //$todo\n  const name = storeObjectName(obj)\n  const store = storeFabric({\n    name,\n    currentState: stateNew,\n  })\n  //$todo\n  store.defaultShape = obj\n  store.on(updater, (_, payload) => payload)\n  return store\n}\n\ndeclare export function createStoreObject<\n  State: $ReadOnlyArray<Store<any> | any>,\n>(\n  obj: State,\n): Store<\n  $TupleMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function createStoreObject<\n  State: {-[key: string]: Store<any> | any},\n>(\n  obj: State,\n): Store<\n  $ObjMap<\n    State,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function createStoreObject(obj: *) {\n  if (Array.isArray(obj)) {\n    return createStoreArray(obj)\n  }\n  return createStoreObjectMap(obj)\n}\n//eslint-disable-next-line\ndeclare export function extract<\n  State: $ReadOnlyArray<Store<any> | any>,\n  NextState: $ReadOnlyArray<Store<any> | any>,\n>(\n  store: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $TupleMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\ndeclare export function extract<\n  State: {-[key: string]: Store<any> | any},\n  NextState: {-[key: string]: Store<any> | any},\n>(\n  obj: Store<State>,\n  extractor: (_: State) => NextState,\n): Store<\n  $ObjMap<\n    NextState,\n    //prettier-ignore\n    <S>(field: Store<S> | S) => S,\n  >,\n>\nexport function extract(store: Store<any>, extractor: any => any) {\n  let result\n  if ('defaultShape' in store) result = extractor((store: any).defaultShape)\n  else result = extractor((store: any).defaultState)\n  return createStoreObject(result)\n}\n","//@flow\nimport type {Event} from 'effector/event'\nimport type {Effect} from 'effector/effect'\nimport type {Store} from './index.h'\nimport {createStore} from './createStore'\n\nexport function restoreObject<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n> {\n  const result = {}\n  for (const [key, value] of Object.entries(obj)) {\n    result[key] = createStore(value)\n  }\n  return result\n}\n\nexport function restoreEffect<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done> {\n  const store = createStore(defaultState)\n  store.on(event.done, (_, {result}) => result)\n  return store\n}\n\nexport function restoreEvent<E>(event: Event<E>, defaultState: E): Store<E> {\n  const store = createStore(defaultState)\n  store.on(event, (_, v) => v)\n  return store\n}\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function restore<Done>(\n  event: Effect<any, Done, any>,\n  defaultState: Done,\n): Store<Done>\ndeclare export function restore<E>(event: Event<E>, defaultState: E): Store<E>\ndeclare export function restore<State: {-[key: string]: Store<any> | any}>(\n  obj: State,\n): $ObjMap<\n  State,\n  //prettier-ignore\n  <S>(field: Store<S> | S) => Store<S>,\n>\n\nconst visitorRestore = {\n  store: ({obj}) => obj,\n  event: ({obj, defaultState}) => restoreEvent(obj, defaultState),\n  effect: ({obj, defaultState}) => restoreEffect(obj, defaultState),\n  __: ({obj}) => restoreObject(obj),\n}\n\nexport function restore(obj: any, defaultState: any): any {\n  return visitorRestore[String(obj?.kind || '__')]({\n    obj,\n    defaultState,\n  })\n}\n","//@flow\n\nimport warning from 'warning'\nimport type {Effect} from './index.h'\nimport {Kind} from 'effector/stdlib'\n\nimport {eventFabric, type Event} from 'effector/event'\nimport type {CompositeName} from '../compositeName'\nimport {exec} from './exec'\nimport {callbacks} from './callbacks'\n\nexport function effectFabric<Payload, Done>({\n  name,\n  domainName,\n  parent,\n  handler,\n}: {\n  name?: string,\n  domainName: string,\n  parent?: CompositeName,\n  handler?: (payload: Payload) => Promise<Done> | Done,\n}): Effect<Payload, Done, *> {\n  //$off\n  const instance: Effect<Payload, Done, any> = eventFabric({\n    name,\n    parent,\n  })\n\n  const eventCreate = instance.create\n  const done: Event<{params: Payload, result: Done}> = eventFabric({\n    name: '' + instance.shortName + ' done',\n    parent,\n  })\n  const fail: Event<{params: Payload, error: *}> = eventFabric({\n    name: '' + instance.shortName + ' fail',\n    parent,\n  })\n\n  instance.done = done\n  instance.fail = fail\n  ;(instance: any).use = fn => {\n    thunk = fn\n    return instance\n  }\n  ;(instance: any).use.getCurrent = (): any => thunk\n  ;(instance: any).kind = Kind.effect\n  ;(instance: any).create = (params: Payload, fullName, args) => {\n    eventCreate(params, instance.getType(), args)\n    return exec(\n      params,\n      callbacks(thunk, result => void done(result), error => void fail(error)),\n    )\n  }\n  //eslint-disable-next-line no-unused-vars\n  let thunk: Function = handler || defaultThunk.bind(instance)\n\n  return instance\n}\n//eslint-disable-next-line no-unused-vars\nfunction defaultThunk(value) {\n  warning(false, 'no thunk used in %s', this.getType())\n  return Promise.resolve()\n}\n","//@flow\n\nexport const __DEBUG__ = false\nexport const __DEV__ = process.env.NODE_ENV !== 'production'\n","//@noflow\n/* eslint-disable */\nimport {__DEV__, __DEBUG__} from 'effector/flags'\n\nvar invariant = function(condition) {\n  if (!condition) {\n    var error = new Error(\n      'Minified exception occurred; use the non-minified dev environment ' +\n      'for the full error message and additional helpful warnings.'\n    );\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nif (__DEV__) {\n  invariant = function(condition, format, a, b, c, d, e, f) {\n    if (__DEBUG__) {\n      if (format === undefined) {\n        throw new Error('invariant requires an error message argument');\n      }\n    }\n    if (!condition) {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      var error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n      error.framesToPop = 1; // we don't care about invariant's own frame\n      throw error;\n    }\n  }\n}\n\nexport default invariant\n","//@flow\n\n//prettier-ignore\nexport opaque type kind: string =\n  | 'none'\n  | 'store'\n  | 'event'\n  | 'effect'\n\nexport const Kind: {\n  +none: kind,\n  +store: kind,\n  +event: kind,\n  +effect: kind,\n} = {\n  none: 'none',\n  store: 'store',\n  event: 'event',\n  effect: 'effect',\n}\n","//@flow\n\nexport const stringRefcount = (): (() => string) => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n","//@flow\n/* eslint-disable */\nimport {__DEV__, __DEBUG__} from 'effector/flags'\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function(/*::condition: any, format: string, args: any*/) {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 1 ? len - 1 : 0);\n    for (var key = 1; key < len; key++) {\n      args[key - 1] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    console.error(message);\n    // try {\n      // --- Welcome ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      // throw new Error(message);\n    // } catch (x) {}\n  }\n\n  warning = function(condition: any, format: string, args: any) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (__DEBUG__) {\n      if (format === undefined) {\n        throw new Error(\n            '`warning(condition, format, ...args)` requires a warning ' +\n            'message argument'\n        );\n      }\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nexport default warning;","//@flow\n\nimport type {Callbacks} from './index.h'\n\nexport const exec = <Args, Done, Fail>(\n  args: Args,\n  cbs: Callbacks<Args, Done, Fail>,\n): Promise<Done> => {\n  declare var throwSymbol: Fail\n  declare var doneSymbol: Promise<Done> & Done\n  let syncError: Fail /*:: = throwSymbol*/\n  let req: Promise<Done> | Done /*:: = doneSymbol*/\n  let successSync = false\n  let fpromise\n  try {\n    req = cbs[2](args)\n    successSync = true\n  } catch (err) {\n    syncError = err\n  }\n  if (successSync === false) {\n    fpromise = Promise.reject(syncError)\n    //TODO deprecate this\n    //$off\n    fpromise.cache = () => undefined\n    const anyway = Promise.resolve(undefined)\n    //$off\n    fpromise.anyway = () => anyway\n    cbs[1]({params: args, error: syncError})\n    return fpromise\n  }\n  if (\n    typeof req === 'object'\n    && req !== null\n    && typeof req.then === 'function'\n  ) {\n    const then: Promise<Done> = (req: any)\n    fpromise = then.then(\n      result => {\n        //$off\n        fpromise.cache = () => result\n        cbs[0]({params: args, result})\n        return result\n      },\n      error => {\n        cbs[1]({params: args, error})\n        throw error\n      },\n    )\n    const anyway = fpromise.then(() => {}, () => {})\n    //$off\n    fpromise.anyway = () => anyway\n    return fpromise\n  }\n  const done: Done = (req: any)\n  fpromise = Promise.resolve(done)\n  //$off\n  fpromise.cache = () => done\n  const anyway = Promise.resolve(undefined)\n  //$off\n  fpromise.anyway = () => anyway\n  cbs[0]({params: args, result: done})\n  return fpromise\n}\n","//@flow\n\nconst cbDone = function(value: any) {\n  const cb = this[3]\n  this.length = 0\n  cb(value)\n}\nconst cbFail = function(value: any) {\n  const cb = this[4]\n  this.length = 0\n  cb(value)\n}\n\nexport const callbacks = (\n  thunk: Function,\n  onDone: (_: *) => void,\n  onFail: (_: *) => void,\n): any => [cbDone, cbFail, thunk, onDone, onFail]\n","//@flow\n\nimport type {Domain, DomainHooks} from './index.h'\nimport type {Store} from 'effector/store'\nimport {type Event, eventFabric} from 'effector/event'\nimport type {Effect} from 'effector/effect'\nimport type {CompositeName} from '../compositeName'\nexport class DomainHistory {\n  /*::;+*/ events: Set<Event<any>> = new Set()\n  /*::;+*/ effects: Set<Effect<any, any, any>> = new Set()\n  /*::;+*/ storages: Set<Store<any>> = new Set()\n  /*::;+*/ domains: Set<Domain> = new Set()\n}\n\nexport function domainHooks(\n  history: DomainHistory,\n  compositeName: CompositeName,\n  parentHooks?: DomainHooks,\n) {\n  let hooks: {\n    domain: Event<Domain>,\n    effect: Event<Effect<any, any, any>>,\n    event: Event<Event<any>>,\n    store: Event<any>,\n  }\n  if (parentHooks) {\n    hooks = childDomainHooks(parentHooks)\n  } else {\n    hooks = singleDomainHooks(compositeName)\n  }\n  hooks.domain.watch(domain => {\n    history.domains.add(domain)\n  })\n  hooks.event.watch(event => {\n    history.events.add(event)\n  })\n  hooks.store.watch(store => {\n    history.storages.add(store)\n  })\n  hooks.effect.watch(effect => {\n    history.effects.add(effect)\n  })\n  return hooks\n}\n\nconst singleDomainHooks = (compositeName: CompositeName) => {\n  const event: Event<Event<any>> = eventFabric({\n    name: `${compositeName.fullName} event hook`,\n    parent: compositeName,\n  })\n  const effect: Event<Effect<any, any, any>> = eventFabric({\n    name: `${compositeName.fullName} effect hook`,\n    parent: compositeName,\n  })\n  const store: Event<Store<any>> = eventFabric({\n    name: `${compositeName.fullName} store hook`,\n    parent: compositeName,\n  })\n  const domain: Event<Domain> = eventFabric({\n    parent: compositeName,\n  })\n  return {event, effect, store, domain}\n}\n\nconst childDomainHooks = (parentHooks: DomainHooks) => {\n  const event: Event<Event<any>> = parentHooks.event.prepend(_ => _)\n  const effect: Event<Effect<any, any, any>> = parentHooks.effect.prepend(\n    _ => _,\n  )\n  const store: Event<Store<any>> = parentHooks.store.prepend(_ => _)\n  const domain: Event<Domain> = parentHooks.domain.prepend(_ => _)\n  return {event, effect, store, domain}\n}\n","//@flow\n\nimport {stringRefcount} from 'effector/stdlib'\nimport {type Store, storeFabric} from 'effector/store'\nimport {type Event, eventFabric} from 'effector/event'\nimport {type Effect, effectFabric} from 'effector/effect'\n\nimport type {Domain, DomainHooks} from './index.h'\nimport {createName, type CompositeName} from '../compositeName'\nimport {DomainHistory, domainHooks} from './hook'\n\nconst nextID = stringRefcount()\n\nexport function domainFabric(\n  nameRaw?: string,\n  parent?: CompositeName,\n  parentHooks?: DomainHooks,\n): Domain {\n  const id = nextID()\n  const name = nameRaw || ''\n  const compositeName = createName(name, parent)\n  const history = new DomainHistory()\n  const hooks = domainHooks(history, compositeName, parentHooks)\n\n  return {\n    compositeName,\n    id,\n    getType() {\n      return compositeName.fullName\n    },\n    onCreateEvent(hook: (newEvent: Event<any>) => any) {\n      history.events.forEach(hook)\n      return hooks.event.watch(hook)\n    },\n    onCreateEffect(hook: (newEffect: Effect<any, any, any>) => any) {\n      history.effects.forEach(hook)\n      return hooks.effect.watch(hook)\n    },\n    onCreateStore(hook: (newStore: Store<any>) => any) {\n      history.storages.forEach(hook)\n      return hooks.store.watch(hook)\n    },\n    onCreateDomain(hook: (newDomain: Domain) => any) {\n      history.domains.forEach(hook)\n      return hooks.domain.watch(hook)\n    },\n    event<Payload>(name?: string): Event<Payload> {\n      const result = eventFabric({\n        name,\n        parent: compositeName,\n      })\n      hooks.event(result)\n      return result\n    },\n    effect<Params, Done, Fail>(name?: string): Effect<Params, Done, Fail> {\n      const result = effectFabric({\n        name,\n        domainName: compositeName.fullName,\n        parent: compositeName,\n      })\n      hooks.effect(result)\n      return result\n    },\n    domain(name?: string) {\n      const result = domainFabric(name, compositeName, hooks)\n      hooks.domain(result)\n      return result\n    },\n    store<T>(state: T): Store<T> {\n      const result = storeFabric({\n        currentState: state,\n        parent: compositeName,\n      })\n      hooks.store(result)\n      return result\n    },\n  }\n}\n","//@flow\n\nimport invariant from 'invariant'\nimport {type Store, createStoreObject} from 'effector/store'\n\n//eslint-disable-next-line no-unused-vars\ndeclare export function combine<R>(fn: () => R): Store<R>\ndeclare export function combine<A, R>(a: Store<A>, fn: (a: A) => R): Store<R>\ndeclare export function combine<A, B, R>(\n  a: Store<A>,\n  b: Store<B>,\n  fn: (a: A, b: B) => R,\n): Store<R>\ndeclare export function combine<A, B, C, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  fn: (a: A, b: B, c: C) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  fn: (a: A, b: B, c: C, d: D) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  fn: (a: A, b: B, c: C, d: D, e: E) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => R,\n): Store<R>\ndeclare export function combine<A, B, C, D, E, F, G, H, I, J, K, R>(\n  a: Store<A>,\n  b: Store<B>,\n  c: Store<C>,\n  d: Store<D>,\n  e: Store<E>,\n  f: Store<F>,\n  g: Store<G>,\n  h: Store<H>,\n  i: Store<I>,\n  j: Store<J>,\n  k: Store<K>,\n  fn: (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K) => R,\n): Store<R>\n\nexport function combine(...args: Array<Store<any>>): Store<any> {\n  invariant(args.length > 0, 'at least one argument required')\n  const handler: Function = (args[args.length - 1]: any)\n  const stores = args.slice(0, -1)\n  const structStore = createStoreObject(stores)\n\n  return structStore.map(list => handler(...list))\n}\n","//@flow\n\nimport {domainFabric} from './domainFabric'\n\nexport function createDomain(name?: string) {\n  return domainFabric(name === undefined ? '' : name)\n}\n","//@flow\n\nimport {effectFabric} from './effectFabric'\nimport type {Effect} from './index.h'\nexport function createEffect<Payload, Done>(\n  name?: string,\n  config?: {\n    handler?: (payload: Payload) => (Promise<Done> | Done),\n  }\n): Effect<Payload, Done, *> {\n  const opts = {}\n  opts.name = name\n  opts.domainName = ''\n  opts.handler = config?.handler\n  return effectFabric(opts)\n}\n","//@flow\n\nimport type {Store} from './index.h'\nimport {type Event, createEvent} from 'effector/event'\n\ndeclare export function createApi<\n  S,\n  Obj: {-[name: string]: (store: S, e: any) => S},\n>(\n  store: Store<S>,\n  setters: Obj,\n): $ObjMap<Obj, <E>(h: (store: S, e: E) => S) => Event<E>>\n\nexport function createApi(store: Store<any>, setters: {[string]: Function}) {\n  const result = {}\n  for (const [key, handler] of Object.entries(setters)) {\n    const event = createEvent(key)\n    store.on(event, (handler: any))\n    result[key] = event\n  }\n  return result\n}\n"],"names":["typeDef","group","t","result","key","type","bind","data","id","nextID","this","createStateRef","current","toString","fx","tag","props","Cmd","Step","single","tag_","childrens","multi","seq","choose","loop","console","error","disposer","i","indexOf","splice","noopIndexOf","noopSplice","runStep","step","ctx","meta","stop","stepVisitor","tryRun","fn","call","arg","val","err","Name","shortName","fullName","path","createName","name","parent","undefined","length","concat","eventFabric","nameRaw","compositeName","makeName","graphite","fabric","instance","payload","args","create","getType","transactions","Ctx","emit","__stepArg","reg","isChanged","walkNode","walkEvent","kind","Kind","event","$$observable","watch","watcher","forward","from","to","runner","newValue","map","mapped","domainName","filter","prepend","contramapped","subscribe","observer","next","opts","toSeq","fromGraphite","push","createWatcher","child","createEvent","getDisplayName","store","setStoreName","rawName","formatMarkName","markName","effectorEmoji","getStoreLabel","storeName","phase","getStoreMarkName","label","debugID","startPhaseTimer","enableUserTimingAPI","supportsUserTiming","clearPendingPhaseMeasurement","componentName","performance","mark","beginMark","beginStoreMark","currentPhaseStore","currentPhase","stopPhaseTimer","warning","formattedMarkName","formattedLabel","formatLabel","measure","clearMarks","clearMeasures","endMark","endStoreMark","getState","storeInstance","plainState","off","currentSubscription","subscribers","get","delete","on","handler","e","set","lastState","readName","eventOrFn","String","invariant","listener","stopPhaseTimerMessage","lastCall","storeFabric","currentState","currentId","defaultState","updater","createDef","Map","setState","value","reduce","newResult","_","reset","firstState","lastResult","lastValue","innerStore","thru","dispatch","action","state","filterBeforeUpdate","createStore","createStoreObject","obj","Array","isArray","stateNew","Math","random","updates","committer","commit","substore","runCmd","transactionContext","nextState","arr","max","storeObjectMaxNames","maxLength","comma","storeObjectArrayName","defaultShape","createStoreArray","Object","assign","entries","keys","storeObjectName","createStoreObjectMap","restoreObject","restoreEffect","done","restoreEvent","v","effectFabric","eventCreate","fail","use","thunk","getCurrent","effect","params","exec","callbacks","Promise","resolve","__DEV__","process","env","NODE_ENV","condition","Error","framesToPop","format","a","b","c","d","f","argIndex","replace","none","stringRefcount","compute","run","update","unsubscribe","commonStepVisitor","command","cmd","transition","items","slice","steps","prev","runCtx","Boolean","newCtx","nextSteps","clearMark","clearStoreMark","def","visitorRestore","__","len","arguments","message","apply","cbs","syncError","req","fpromise","successSync","reject","cache","anyway","then","cbDone","cb","cbFail","onDone","onFail","DomainHistory","events","Set","effects","storages","domains","list","domainFabric","parentHooks","history","hooks","domain","childDomainHooks","singleDomainHooks","add","domainHooks","onCreateEvent","hook","forEach","onCreateEffect","onCreateStore","onCreateDomain","config","extractor","setters"],"mappings":"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"}