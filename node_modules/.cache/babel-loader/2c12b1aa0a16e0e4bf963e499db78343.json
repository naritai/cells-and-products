{"ast":null,"code":"import _classCallCheck from \"/Users/Wave/Desktop/cells/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _defineProperty from \"/Users/Wave/Desktop/cells/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/Users/Wave/Desktop/cells/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction t(t, e) {\n  var r = {};\n\n  for (var _o in e) {\n    r[_o] = n.bind({\n      key: _o,\n      group: t\n    });\n  }\n\n  return r;\n}\n\nfunction n(t) {\n  return {\n    id: J(),\n    type: this.key,\n    group: this.group,\n    data: t\n  };\n}\n\nfunction e(t) {\n  return {\n    id: (++R).toString(36),\n    current: t\n  };\n}\n\nfunction r(t, n) {\n  if (t in L) return K.single(L[t](n));\n  var e = t;\n\n  for (var r = arguments.length, o = new Array(r > 2 ? r - 2 : 0), a = 2; a < r; a++) {\n    o[a - 2] = arguments[a];\n  }\n\n  switch (e) {\n    case 'single':\n      return K.single(o[0]);\n\n    case 'multi':\n      return K.multi(o);\n\n    case 'seq':\n      return K.seq(o);\n\n    case 'choose':\n      return K.choose(n);\n\n    case 'loop':\n      return K.loop(n);\n  }\n\n  return 'function' == typeof t ? t(n, o) : (console.error('unknown node \"%s\"', t), null);\n}\n\nfunction o() {\n  var t = this.indexOf();\n  -1 !== t && (this.splice(t, 1), this.indexOf = U, this.splice = X);\n}\n\nfunction a(t, n, e) {\n  e.stop = 0, tt[t.type](t, n, e);\n}\n\nfunction i(t) {\n  try {\n    t.result = t.fn.call(null, t.arg, t.val);\n  } catch (n) {\n    console.error(n), t.err = 1;\n  }\n\n  return t;\n}\n\nfunction u(t, n, e) {\n  this.shortName = t, this.fullName = n, this.path = e;\n}\n\nfunction c(t, n) {\n  var e, r;\n  var o = t;\n  return void 0 === n ? (e = 0 === t.length ? [] : [t], r = t) : 0 === t.length ? (e = n.path, r = n.fullName) : (e = n.path.concat([t]), r = 0 === n.fullName.length ? t : n.fullName + '/' + t), new u(o, r, e);\n}\n\nfunction s(t) {\n  var n = t.name,\n      e = t.parent;\n\n  var o = et(),\n      i = n || o,\n      u = function (t) {\n    var n = null == e ? void 0 : e.fullName;\n    return n ? n + '/' + t : t || '';\n  }(i),\n      f = c(i, e),\n      d = rt({\n    fullName: u\n  }),\n      m = function t(n) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), o = 1; o < e; o++) {\n      r[o - 1] = arguments[o];\n    }\n\n    return t.create(n, u, r);\n  };\n\n  return m.getType = function () {\n    return f.fullName;\n  }, m.create = function (t) {\n    return function (t) {\n      (function (n) {\n        var e = {\n          transactions: [],\n          stop: 0,\n          ctx: Q.emit({\n            __stepArg: t\n          }),\n          reg: {\n            isChanged: 1\n          },\n          val: {}\n        };\n        a(n, e.ctx, e);\n\n        for (var _t = 0; _t < e.transactions.length; _t++) {\n          e.transactions[_t]();\n        }\n\n        e.transactions.length = 0;\n      })(m.graphite.seq);\n    }(t), t;\n  }, m.kind = F.event, m[D] = function () {\n    return m;\n  }, m.id = o, m.watch = function (t, n) {\n    return l({\n      from: t,\n      to: {\n        graphite: {\n          seq: r(\"run\", {\n            runner: function runner(e) {\n              return n(e, t.getType());\n            }\n          })\n        }\n      }\n    });\n  }.bind(null, m), m.map = function (t, n) {\n    var e = s({\n      name: t.shortName + ' → *',\n      parent: t.domainName\n    });\n    return l({\n      from: t,\n      to: {\n        graphite: {\n          seq: r(\"seq\", null, r(\"compute\", {\n            fn: function (t) {\n              function n(n) {\n                return t.apply(this, arguments);\n              }\n\n              return n.toString = function () {\n                return t.toString();\n              }, n;\n            }(function (t) {\n              return n(t);\n            })\n          }), e.graphite.seq)\n        }\n      }\n    }), e;\n  }.bind(null, m), m.filter = function (t, n) {\n    var e = s({\n      name: t.shortName + ' →? *',\n      parent: t.domainName\n    });\n    return l({\n      from: t,\n      to: {\n        graphite: {\n          seq: r(\"seq\", null, r(\"compute\", {\n            fn: function (t) {\n              function n(n) {\n                return t.apply(this, arguments);\n              }\n\n              return n.toString = function () {\n                return t.toString();\n              }, n;\n            }(function (t) {\n              return n(t);\n            })\n          }), r(\"filter\", {\n            filter: function filter(t) {\n              return void 0 !== t;\n            }\n          }), e.graphite.seq)\n        }\n      }\n    }), e;\n  }.bind(null, m), m.prepend = function (t, n) {\n    var e = s({\n      name: '* → ' + t.shortName,\n      parent: t.domainName\n    });\n    return l({\n      from: e,\n      to: {\n        graphite: {\n          seq: r(\"seq\", null, r(\"compute\", {\n            fn: function (t) {\n              function n(n) {\n                return t.apply(this, arguments);\n              }\n\n              return n.toString = function () {\n                return t.toString();\n              }, n;\n            }(function (t) {\n              return n(t);\n            })\n          }), t.graphite.seq)\n        }\n      }\n    }), e;\n  }.bind(null, m), m.subscribe = function (t, n) {\n    return t.watch(function (t) {\n      return n.next(t);\n    });\n  }.bind(null, m), m.graphite = d, m.shortName = i, m.domainName = e, m.compositeName = f, m;\n}\n\nfunction l(t) {\n  var n = t.to.graphite.seq,\n      e = t.from.graphite;\n  return e.next.data.push(n), Y({\n    child: n,\n    parent: e\n  });\n}\n\nfunction f(t) {\n  return s({\n    name: t\n  });\n}\n\nfunction d(t, n) {\n  return function (e) {\n    return n(t.getState(), e);\n  };\n}\n\nfunction m(t) {\n  return t.compositeName ? t.compositeName.fullName : t.domainName ? t.domainName.fullName : t.id;\n}\n\nfunction p(t, n) {\n  var e = c(n, t.domainName);\n  t.shortName = n, t.compositeName = e;\n}\n\nfunction h(t) {\n  return \"\".concat(ct, \" \").concat(t);\n}\n\nfunction g(t, n) {\n  return \"\".concat(t, \".\").concat(n);\n}\n\nfunction v(t, n) {\n  return \"\".concat(t, \" (#\").concat(n, \")\");\n}\n\nfunction b(t, n) {\n  if (lt) {\n    if (!st) return;\n    dt(), function (t, n) {\n      var e = m(t),\n          r = t.id;\n\n      (function (t) {\n        performance.mark(h(t));\n      })(v(g(e, n), r));\n    }(t, n), ut = t, at = n;\n  }\n}\n\nfunction y(t) {\n  if (lt) {\n    if (!st) return;\n    null !== at && null !== ut && function (t, n, e) {\n      var r = m(t),\n          o = t.id,\n          a = g(r, n);\n\n      (function (t, n, e) {\n        var r = h(n),\n            o = ft(t, e);\n\n        try {\n          performance.measure(o, r);\n        } catch (t) {}\n\n        performance.clearMarks(r), performance.clearMeasures(o);\n      })(a, v(a, o), e);\n    }(ut, at, t), at = null, ut = null;\n  }\n}\n\nfunction S(t) {\n  return t.plainState.current;\n}\n\nfunction N(t, n) {\n  var e = t.subscribers.get(n);\n  void 0 !== e && (e(), t.subscribers.delete(n));\n}\n\nfunction w(t, n, e) {\n  var o = n;\n  return t.subscribers.set(o, l({\n    from: o,\n    to: {\n      graphite: {\n        seq: r(\"seq\", null, r(\"compute\", {\n          fn: function fn(n) {\n            var r = S(t);\n            return e(r, n, mt(o));\n          }\n        }), r(\"filter\", {\n          filter: function filter(n) {\n            return n !== S(t) && void 0 !== n;\n          }\n        }), t.graphite.seq)\n      }\n    }\n  })), this;\n}\n\nfunction q(t, n, e) {\n  switch (String((null == n ? void 0 : n.kind) || '__')) {\n    case 'store':\n    case 'event':\n    case 'effect':\n      return z('function' == typeof e, 'watch requires function handler'), n.watch(function (r) {\n        return e(S(t), r, mt(n));\n      });\n\n    case '__':\n    default:\n      return z('function' == typeof n, 'watch requires function handler'), x(t, n);\n  }\n}\n\nfunction x(t, n) {\n  z('function' == typeof n, 'Expected the listener to be a function');\n  var e = null,\n      o = S(t);\n  b(t, 'subscribe');\n\n  try {\n    n(o), e = 'Initial';\n  } catch (t) {\n    console.error(t), e = 'Got initial error';\n  }\n\n  return y(e), l({\n    from: t,\n    to: {\n      graphite: {\n        seq: r(\"run\", {\n          runner: function runner(e) {\n            var r = null;\n\n            if (b(t, 'subscribe'), e !== o) {\n              o = e;\n\n              try {\n                n(e);\n              } catch (t) {\n                console.error(t), r = 'Got error';\n              }\n\n              y(r);\n            } else y(r);\n          }\n        })\n      }\n    }\n  });\n}\n\nfunction k(t) {\n  var n = t.currentState,\n      o = t.name,\n      a = t.parent,\n      i = e(n),\n      u = i.id,\n      c = n,\n      s = f('update ' + u),\n      d = {\n    graphite: pt(i),\n    kind: F.store,\n    id: u,\n    shortName: u,\n    domainName: a,\n    defaultState: c,\n    plainState: i,\n    subscribers: new Map()\n  };\n  o && p(d, o);\n  var m = {\n    graphite: d.graphite,\n    kind: F.store,\n    id: u,\n    shortName: u,\n    domainName: a,\n    setState: function setState(t, n) {\n      var e = ('function' == typeof n ? n : function (t, n) {\n        return n;\n      })(S(d), t);\n      s(e);\n    },\n    off: N.bind(null, d),\n    watch: q.bind(null, d),\n    subscribe: x.bind(null, d),\n    getState: S.bind(null, d)\n  };\n  return m.reset = function (t, n) {\n    return w.call(this, t, n, function () {\n      return t.defaultState;\n    });\n  }.bind(m, d), m.on = w.bind(m, d), m.defaultState = c, m.map = function (t, n, e) {\n    b(t, 'map');\n    var o,\n        a = t.getState(),\n        i = null;\n\n    try {\n      o = n(a, e), i = 'Initial';\n    } catch (t) {\n      console.error(t), i = 'Got initial error';\n    }\n\n    y(i);\n    var u = this({\n      name: t.shortName + ' → *',\n      currentState: o,\n      parent: t.domainName\n    });\n    return l({\n      from: t,\n      to: {\n        graphite: {\n          seq: r(\"seq\", null, r(\"compute\", {\n            fn: function fn(e) {\n              b(t, 'map'), a = e;\n              var r = null;\n              var o = u.getState();\n              var i;\n\n              try {\n                i = n(e, o);\n              } catch (t) {\n                console.error(t), r = 'Got error';\n              }\n\n              return y(r), i;\n            }\n          }), r(\"filter\", {\n            filter: function filter(t) {\n              var n = t !== u.getState() && void 0 !== t;\n              return n && (o = t), y(null), n;\n            }\n          }), u.graphite.seq)\n        }\n      }\n    }), u;\n  }.bind(k, m), m.thru = function (t) {\n    return t(this);\n  }.bind(m), m.dispatch = function (t) {\n    return t;\n  }.bind(null), m[D] = function (t) {\n    var n = {\n      subscribe: function subscribe(n) {\n        return z('object' == typeof n && null !== n, 'Expected the observer to be an object.'), x(t, function (t) {\n          n.next && n.next(t);\n        });\n      }\n    };\n    return n[D] = function () {\n      return this;\n    }, n;\n  }.bind(null, d), o && p(m, o), m.on(s, function (t, n) {\n    return n;\n  }), m;\n}\n\nfunction _(t) {\n  return void 0 !== t && t !== this.current;\n}\n\nfunction j(t) {\n  return k({\n    currentState: t\n  });\n}\n\nfunction A(t) {\n  return Array.isArray(t) ? function (t) {\n    var n = _toConsumableArray(t),\n        e = _toConsumableArray(t),\n        o = f('update ' + Math.random().toString());\n\n    var a = [];\n\n    var i = function i() {\n      return a = [], function () {\n        var t = c.getState();\n\n        for (var _i = 0; _i < a.length; _i++) {\n          var _n = a[_i];\n          t = _n(t);\n        }\n\n        u = i(), o(t);\n      };\n    };\n\n    var u = i();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var t = _step.value;\n        var n = t[0],\n            o = t[1];\n\n        if (o.kind === F.store) {\n          var _t3 = o,\n              _i2 = r(\"run\", {\n            runner: function runner() {}\n          });\n\n          _i2.data.data.transactionContext = function (t) {\n            return a.push(function (e) {\n              var r = _toConsumableArray(e);\n\n              return r[n] = t, r;\n            }), u;\n          }, e[n] = _t3.getState(), l({\n            from: _t3,\n            to: {\n              graphite: {\n                seq: _i2\n              }\n            }\n          });\n        }\n      };\n\n      for (var _iterator = n.map(function (t, n) {\n        return [n, t];\n      })[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        _loop();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    var c = k({\n      name: function (t) {\n        var n = 0;\n        var e = ot - 1,\n            r = t.length - 1;\n        var o = 'combine(';\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = t[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _a = _step2.value;\n\n            var _t2 = n === e || r === n ? '' : ', ';\n\n            if (o += _a.kind !== F.store ? _a.toString() + _t2 : m(_a) + _t2, n += 1, '' === _t2) break;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return o + ')';\n      }(t),\n      currentState: e\n    });\n    return c.defaultShape = t, c.on(o, function (t, n) {\n      return n;\n    }), c;\n  }(t) : function (t) {\n    var n = Object.assign({}, t),\n        e = Object.assign({}, t),\n        o = f('update ' + Math.random().toString());\n    var a = [];\n\n    var i = function i() {\n      return a = [], function () {\n        var t = c.getState();\n\n        for (var _i3 = 0; _i3 < a.length; _i3++) {\n          var _n2 = a[_i3];\n          t = _n2(t);\n        }\n\n        u = i(), o(t);\n      };\n    };\n\n    var u = i();\n\n    var _arr = Object.entries(n);\n\n    var _loop2 = function _loop2() {\n      var t = _arr[_i4];\n      var n = t[0],\n          o = t[1];\n      if (o.kind !== F.store) return \"continue\";\n      var i = r(\"run\", {\n        runner: function runner() {}\n      });\n      i.data.data.transactionContext = function (t) {\n        return a.push(function (e) {\n          return Object.assign({}, e, _defineProperty({}, n, t));\n        }), u;\n      }, e[n] = o.getState(), l({\n        from: o,\n        to: {\n          graphite: {\n            seq: i\n          }\n        }\n      });\n    };\n\n    for (var _i4 = 0; _i4 < _arr.length; _i4++) {\n      var _ret = _loop2();\n\n      if (_ret === \"continue\") continue;\n    }\n\n    var c = k({\n      name: function (t) {\n        var n = 0;\n        var e = Object.keys(t),\n            r = ot - 1,\n            o = e.length - 1;\n        var a = 'combine(';\n\n        for (var _e in t) {\n          var _i5 = n === r || o === n ? '' : ', ',\n              _u = t[_e];\n\n          if (a += _u.kind !== F.store ? _u.toString() + _i5 : m(_u) + _i5, n += 1, '' === _i5) break;\n        }\n\n        return a + ')';\n      }(t),\n      currentState: e\n    });\n    return c.defaultShape = t, c.on(o, function (t, n) {\n      return n;\n    }), c;\n  }(t);\n}\n\nfunction C(t, n) {\n  var e;\n  return A(e = n('defaultShape' in t ? t.defaultShape : t.defaultState));\n}\n\nfunction $(t, n) {\n  var e = {};\n\n  var _arr2 = Object.entries(n);\n\n  for (var _i6 = 0; _i6 < _arr2.length; _i6++) {\n    var _r = _arr2[_i6];\n\n    var _n3 = _r[0],\n        _o2 = _r[1],\n        _a2 = f(_n3);\n\n    t.on(_a2, _o2), e[_n3] = _a2;\n  }\n\n  return e;\n}\n\nfunction E(t) {\n  var n = {};\n\n  var _arr3 = Object.entries(t);\n\n  for (var _i7 = 0; _i7 < _arr3.length; _i7++) {\n    var _e2 = _arr3[_i7];\n    n[_e2[0]] = j(_e2[1]);\n  }\n\n  return n;\n}\n\nfunction O(t, n) {\n  var e = j(n);\n  return e.on(t.done, function (t, n) {\n    return n.result;\n  }), e;\n}\n\nfunction M(t, n) {\n  var e = j(n);\n  return e.on(t, function (t, n) {\n    return n;\n  }), e;\n}\n\nfunction T(t, n) {\n  return ht[String((null == t ? void 0 : t.kind) || '__')]({\n    obj: t,\n    defaultState: n\n  });\n}\n\nfunction P() {\n  for (var t = arguments.length, n = new Array(t), e = 0; e < t; e++) {\n    n[e] = arguments[e];\n  }\n\n  z(n.length > 0, 'at least one argument required');\n  var r = n[n.length - 1];\n  return A(n.slice(0, -1)).map(function (t) {\n    return r.apply(void 0, _toConsumableArray(t));\n  });\n}\n\nfunction G(t) {\n  var n = t.parent,\n      e = t.handler;\n  var r = s({\n    name: t.name,\n    parent: n\n  }),\n      o = r.create,\n      a = s({\n    name: r.shortName + ' done',\n    parent: n\n  }),\n      i = s({\n    name: r.shortName + ' fail',\n    parent: n\n  });\n  r.done = a, r.fail = i, r.use = function (t) {\n    return u = t, r;\n  }, r.use.getCurrent = function () {\n    return u;\n  }, r.kind = F.effect, r.create = function (t, n, e) {\n    return o(t, r.getType(), e), bt(t, Nt(u, function (t) {\n      return void a(t);\n    }, function (t) {\n      return void i(t);\n    }));\n  };\n\n  var u = e || function () {\n    return vt(0, 'no thunk used in %s', this.getType()), Promise.resolve();\n  }.bind(r);\n\n  return r;\n}\n\nfunction B(t, n) {\n  var e = {};\n  return e.name = t, e.domainName = '', e.handler = null == n ? void 0 : n.handler, G(e);\n}\n\nfunction I(t) {\n  return function t(n, e, r) {\n    var o = kt(),\n        a = c(n || '', e),\n        i = new wt(),\n        u = function (t, n, e) {\n      var r;\n      return (r = e ? xt(e) : qt(n)).domain.watch(function (n) {\n        t.domains.add(n);\n      }), r.event.watch(function (n) {\n        t.events.add(n);\n      }), r.store.watch(function (n) {\n        t.storages.add(n);\n      }), r.effect.watch(function (n) {\n        t.effects.add(n);\n      }), r;\n    }(i, a, r);\n\n    return {\n      compositeName: a,\n      id: o,\n      getType: function getType() {\n        return a.fullName;\n      },\n      onCreateEvent: function onCreateEvent(t) {\n        return i.events.forEach(t), u.event.watch(t);\n      },\n      onCreateEffect: function onCreateEffect(t) {\n        return i.effects.forEach(t), u.effect.watch(t);\n      },\n      onCreateStore: function onCreateStore(t) {\n        return i.storages.forEach(t), u.store.watch(t);\n      },\n      onCreateDomain: function onCreateDomain(t) {\n        return i.domains.forEach(t), u.domain.watch(t);\n      },\n      event: function event(t) {\n        var n = s({\n          name: t,\n          parent: a\n        });\n        return u.event(n), n;\n      },\n      effect: function effect(t) {\n        var n = G({\n          name: t,\n          domainName: a.fullName,\n          parent: a\n        });\n        return u.effect(n), n;\n      },\n      domain: function domain(n) {\n        var e = t(n, a, u);\n        return u.domain(e), e;\n      },\n      store: function store(t) {\n        var n = k({\n          currentState: t,\n          parent: a\n        });\n        return u.store(n), n;\n      }\n    };\n  }(void 0 === t ? '' : t);\n}\n\nimport D from 'symbol-observable';\nvar V = 'production' !== process.env.NODE_ENV;\n\nvar W = function W(t) {\n  if (!t) {\n    var n = new Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");\n    throw n.framesToPop = 1, n;\n  }\n};\n\nV && (W = function W(t, n, e, r, o, a, i, u) {\n  if (!t) {\n    var c = [e, r, o, a, i, u],\n        s = 0,\n        l = new Error(n.replace(/%s/g, function () {\n      return c[s++];\n    }));\n    throw l.name = 'Invariant Violation', l.framesToPop = 1, l;\n  }\n});\nvar z = W;\n\nvar F = {\n  none: 'none',\n  store: 'store',\n  event: 'event',\n  effect: 'effect'\n},\n    H = function H() {\n  var t = 0;\n  return function () {\n    return (++t).toString(36);\n  };\n},\n    J = H(),\n    K = t('step', {\n  single: null,\n  multi: null,\n  seq: null,\n  choose: null,\n  loop: null\n}),\n    L = t('cmd', {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null\n}),\n    Q = t('ctx', {\n  compute: null,\n  emit: null,\n  run: null,\n  filter: null,\n  update: null\n});\n\nvar R = 0;\n\nvar U = function U() {\n  return -1;\n},\n    X = function X() {\n  return [];\n},\n    Y = function Y(t) {\n  var n = t.parent.next.data,\n      e = {\n    indexOf: n.indexOf.bind(n, t.child),\n    splice: n.splice.bind(n)\n  },\n      r = o.bind(e);\n  return r.unsubscribe = o.bind(e), r;\n},\n    Z = {\n  single: function single(t, n, e) {\n    e.arg = n.data.__stepArg, e.ctx = nt[t.data.type].cmd(t.data, e), e.stop = !nt[e.ctx.type].transition(e.reg);\n  },\n  multi: function multi(t, n, e) {\n    var r = t.data.slice();\n\n    for (var _t4 = 0; _t4 < r.length; _t4++) {\n      a(r[_t4], n, e);\n    }\n\n    e.stop = 0;\n  },\n  seq: function seq(t, n, e) {\n    e.ctx = n;\n    var r = t.data.slice();\n\n    for (var _t5 = 0; _t5 < r.length && (a(r[_t5], e.ctx, e), !e.stop); _t5++) {\n      ;\n    }\n  }\n},\n    tt = {};\n\ntt.single = Z.single, tt.multi = Z.multi, tt.seq = Z.seq;\n\nvar nt = {\n  emit: {\n    cmd: function cmd(t, n) {\n      return Q.emit({\n        __stepArg: n.arg\n      });\n    },\n    transition: function transition() {\n      return 1;\n    }\n  },\n  filter: {\n    cmd: function cmd(t, n) {\n      var e = Q.filter({\n        __stepArg: n.arg\n      }),\n          r = i({\n        err: 0,\n        result: null,\n        arg: n.arg,\n        val: n.val,\n        fn: t.data.filter\n      });\n      return n.reg.isChanged = Boolean(r.result), e;\n    },\n    transition: function transition(t) {\n      return Boolean(t.isChanged);\n    }\n  },\n  run: {\n    cmd: function cmd(t, n) {\n      var e = Q.run({});\n      return 'transactionContext' in t.data && n.transactions.push(t.data.transactionContext(n.arg)), i({\n        err: 0,\n        result: null,\n        arg: n.arg,\n        val: n.val,\n        fn: t.data.runner\n      }), e;\n    },\n    transition: function transition() {\n      return 0;\n    }\n  },\n  update: {\n    cmd: function cmd(t, n) {\n      var r;\n      return (r = 'val' in t.data ? n.val[t.data.val] = n.val[t.data.val] || e(null) : t.data.store).current = n.arg, Q.update({\n        __stepArg: n.arg\n      });\n    },\n    transition: function transition() {\n      return 1;\n    }\n  },\n  compute: {\n    cmd: function cmd(t, n) {\n      var e = Q.compute({\n        __stepArg: null\n      }),\n          r = i({\n        err: 0,\n        result: null,\n        arg: n.arg,\n        val: n.val,\n        fn: t.data.fn\n      });\n      return n.reg.isChanged = !r.err && void 0 !== r.result, r.err || (e.data.__stepArg = r.result), e;\n    },\n    transition: function transition(t) {\n      return Boolean(t.isChanged);\n    }\n  }\n},\n    et = H(),\n    rt = function rt(t) {\n  var n = r(\"multi\", null);\n  return {\n    next: n,\n    seq: r(\"seq\", null, r(\"emit\", {\n      fullName: t.fullName\n    }), n)\n  };\n},\n    ot = 25;\n\nvar at = null,\n    ut = null;\n\nvar ct = '☄',\n    st = 'undefined' != typeof performance && 'function' == typeof performance.mark && 'function' == typeof performance.clearMarks && 'function' == typeof performance.measure && 'function' == typeof performance.clearMeasures,\n    lt = V,\n    ft = function ft(t, n) {\n  return \"\".concat(\"\".concat(ct, \" \"), t).concat(n ? \" Warning: \".concat(n) : '');\n},\n    dt = function dt() {\n  null !== at && null !== ut && function (t, n) {\n    var e = m(t),\n        r = t.id;\n\n    (function (t) {\n      performance.clearMarks(h(t));\n    })(v(g(e, n), r));\n  }(ut, at), ut = null, at = null;\n},\n    mt = function mt(t) {\n  switch (t.kind) {\n    case F.store:\n      return t.shortName;\n\n    default:\n      return t.getType();\n  }\n},\n    pt = function pt(t) {\n  var n = {};\n  return n.next = r(\"multi\", null), n.seq = r(\"seq\", null, r(\"filter\", {\n    filter: _.bind(t)\n  }), r(\"update\", {\n    store: t\n  }), n.next), n;\n},\n    ht = {\n  store: function store(t) {\n    return t.obj;\n  },\n  event: function event(t) {\n    return M(t.obj, t.defaultState);\n  },\n  effect: function effect(t) {\n    return O(t.obj, t.defaultState);\n  },\n  __: function __(t) {\n    return E(t.obj);\n  }\n};\n\nvar gt = function gt() {};\n\nV && (gt = function gt(t, n, e) {\n  var r = arguments.length;\n  e = new Array(r > 2 ? r - 2 : 0);\n\n  for (var o = 2; o < r; o++) {\n    e[o - 2] = arguments[o];\n  }\n\n  t || function (t, n) {\n    var e = arguments.length;\n    n = new Array(e > 1 ? e - 1 : 0);\n\n    for (var r = 1; r < e; r++) {\n      n[r - 1] = arguments[r];\n    }\n\n    var o = 0,\n        a = 'Warning: ' + t.replace(/%s/g, function () {\n      return n[o++];\n    });\n    console.error(a);\n  }.apply(null, [n].concat(e));\n});\nvar vt = gt;\n\nvar bt = function bt(t, n) {\n  var e,\n      r,\n      o,\n      a = 0;\n\n  try {\n    r = n[2](t), a = 1;\n  } catch (t) {\n    e = t;\n  }\n\n  if (0 == a) {\n    (o = Promise.reject(e)).cache = function () {\n      return void 0;\n    };\n\n    var _r2 = Promise.resolve(void 0);\n\n    return o.anyway = function () {\n      return _r2;\n    }, n[1]({\n      params: t,\n      error: e\n    }), o;\n  }\n\n  if ('object' == typeof r && null !== r && 'function' == typeof r.then) {\n    var _e3 = (o = r.then(function (e) {\n      return o.cache = function () {\n        return e;\n      }, n[0]({\n        params: t,\n        result: e\n      }), e;\n    }, function (e) {\n      throw n[1]({\n        params: t,\n        error: e\n      }), e;\n    })).then(function () {}, function () {});\n\n    return o.anyway = function () {\n      return _e3;\n    }, o;\n  }\n\n  var i = r;\n\n  (o = Promise.resolve(i)).cache = function () {\n    return i;\n  };\n\n  var u = Promise.resolve(void 0);\n  return o.anyway = function () {\n    return u;\n  }, n[0]({\n    params: t,\n    result: i\n  }), o;\n},\n    yt = function yt(t) {\n  var n = this[3];\n  this.length = 0, n(t);\n},\n    St = function St(t) {\n  var n = this[4];\n  this.length = 0, n(t);\n},\n    Nt = function Nt(t, n, e) {\n  return [yt, St, t, n, e];\n};\n\nvar wt = function wt() {\n  _classCallCheck(this, wt);\n\n  this.events = new Set(), this.effects = new Set(), this.storages = new Set(), this.domains = new Set();\n};\n\nvar qt = function qt(t) {\n  return {\n    event: s({\n      name: \"\".concat(t.fullName, \" event hook\"),\n      parent: t\n    }),\n    effect: s({\n      name: \"\".concat(t.fullName, \" effect hook\"),\n      parent: t\n    }),\n    store: s({\n      name: \"\".concat(t.fullName, \" store hook\"),\n      parent: t\n    }),\n    domain: s({\n      parent: t\n    })\n  };\n},\n    xt = function xt(t) {\n  return {\n    event: t.event.prepend(function (t) {\n      return t;\n    }),\n    effect: t.effect.prepend(function (t) {\n      return t;\n    }),\n    store: t.store.prepend(function (t) {\n      return t;\n    }),\n    domain: t.domain.prepend(function (t) {\n      return t;\n    })\n  };\n},\n    kt = H();\n\nexport { P as combine, I as createDomain, f as createEvent, l as forward, B as createEffect, j as createStore, A as createStoreObject, p as setStoreName, C as extract, $ as createApi, T as restore, M as restoreEvent, O as restoreEffect, E as restoreObject, d as withProps };","map":null,"metadata":{},"sourceType":"module"}